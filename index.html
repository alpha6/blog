<!DOCTYPE html>
<html>
    <head>
	<meta charset="utf-8">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <link href="/theme/css/skeleton.css" rel="stylesheet">
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <title>Just another blog</title>
        <link href="/blog/index.atom" rel="alternate" type="application/atom+xml">
        <link href="/blog/index.rss" rel="alternate" type="application/rss+xml">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/">Just another blog</a>
                    <ul>
                        <li>
                            <a href="/">Blog</a>
                        </li>
                    </ul>
                </div>
            </nav>
            
        </header>
        <div class="main container">
            
<div class="row">

    <div class="nine columns">
        <main>

            <article>
                <header>
                    <h1><a href="/blog/2015/09/14/get-package-methods/">Получение методов пакета</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/perl/" rel="tag">perl</a>
                        <a href="/blog/tag/note/" rel="tag">note</a>
                        <a href="/blog/tag/package/" rel="tag">package</a>
                    </p>

                    <aside>
                        <p><time datetime="2015-09-14">
                            Posted on 2015-09-14
                        </time>
                        </p>
                    </aside>

                </header>

                <p>Для получения методов пакета Foo::Bar делаем:</p>

<pre><code>print Dumper(\%Foo::Bar::);
</code></pre>

<p>Для проверки существования метода:</p>

<pre><code>if (Foo::Bar::.$method_name) {
    #some stuff
}
</code></pre>

<p>Для получения методов текущего пакета:</p>

<pre><code>print Dumper(\%main::)
</code></pre>

<p>Но если подключены дополнительные библиотеки - в выводе будут методы всех подключенных библиотек.</p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2015/05/24/ubuntu-bcm43142/">ubuntu 15.04 и BCM43142</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/Ubuntu/" rel="tag">Ubuntu</a>
                        <a href="/blog/tag/note/" rel="tag">note</a>
                    </p>

                    <aside>
                        <p><time datetime="2015-05-24">
                            Posted on 2015-05-24
                        </time>
                        </p>
                    </aside>

                </header>

                <p>После апгрейда Ubuntu 14.04 на Kubuntu 15.04 выяснилось что Wi-Fi на моем ноутбуке работать не хочет от слова &quot;совсем&quot;. И если в 14.04 после подключения к интернету он сам предлагал доустановить нужные драйвера - то в 15.04 магия не срабатывала и Wi-Fi не работал.</p>

<p>Симптомы:
* в NetworkManager нет даже пункта про беспроводные подключения.
* <code># lshw -c Network</code> говорит что-то вроде:</p>

<pre><code>*-network UNCLAIMED     
   description: Network controller
   product: BCM43142 802.11b/g/n
   vendor: Broadcom Corporation
   physical id: 0
   bus info: pci@0000:02:00.0
   version: 01
   width: 64 bits
   clock: 33MHz
   capabilities: bus_master cap_list
   configuration: latency=0
   resources: memory:90500000-90507fff
</code></pre>

<p>Как можно заметить - устройство карте не назначено. Значит надо доустановить пакет с прошивкой для карты. С 14.04 эта карта поддерживается в официальных драйверах, так что просто устанавливаем пакет руками:</p>

<pre><code>sudo apt-get install bcmwl-kernel-source
</code></pre>

<p>Перезагружемся и видим в NetworkManager раздел с беспроводными сетями.</p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2015/05/20/airport-linux/">Превращаем Linux компьютер в AirPlay приемник</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/airplay/" rel="tag">airplay</a>
                        <a href="/blog/tag/linux/" rel="tag">linux</a>
                        <a href="/blog/tag/shairport/" rel="tag">shairport</a>
                    </p>

                    <aside>
                        <p><time datetime="2015-05-20">
                            Posted on 2015-05-20
                        </time>
                        </p>
                    </aside>

                </header>

                <p>Захотелось мне как-то играть музыку с мака на колонки без проводов. Раньше для этого я пользовался AirPort Express, када были воткнуты колонки. Но сия халява кончилась и теперь надо что-то изобретать.</p>

<p>Быстрый поиск по интернетам показал существование демона shairport, который предствляет собой AirPlay приемник для Linux. Проблема в том, что данный демон уже давно не поддерживается и автор прямо отказался от его поддержки. Но благодаря великой силе форков гитхаба был найден проект <a href="https://github.com/mikebrady/shairport-sync">shairport-sync</a>, который является форком shairport с допилами и поддерживается в настоящее время. То что надо!</p>

<p>Итак, краткий мануал по установке. Я взял старый asus eee 900, на котором стоит xubuntu 14.04LTS. По совместительству он работает у меня домашним сервером.</p>

<ul>
<li>Клонируем к себе репозиторий <code>git clone https://github.com/mikebrady/shairport-sync.git</code></li>
<li>Устанавливаем зависимости нужное для сборки <code>apt install build-essential autoconf checkinstall libtool libdaemon-dev libasound2-dev libpopt-dev</code></li>
<li>Устанавливаем Avahi <code>apt install avahi-daemon libavahi-client-dev</code></li>
<li>Устанавливаем зависимости для работы с SSL <code>apt install libssl-dev</code>. Демон умеет работать с OpenSSL или PolarSSL, но этот пакет нужен для обеих библиотек.</li>
<li>Я использовал PolarSSL для сборки, но, в целом, никакой разницы нет. Устанавливаем PolarSSL <code>apt install libpolarssl-dev</code></li>
<li>Запускаем autoconf <code>autoreconf -i -f</code> после этого будет сгенерирован файл configure.</li>
<li><code>$ ./configure --with-alsa --with-avahi --with-ssl=polarssl</code></li>
<li><code>make</code></li>
<li><code>sudo checkinstall</code>. Checkinstall задаст несколько вопросов, на них можно ответить по умолчанию, единственное что надо задать поле <code>version</code> в виде числа. Т.к. по умолчанию туда попадает значение <code>sync</code> и checkinstall падает с ошибкой создания пакета.</li>
</ul>

<p>Почему вместо <code>make install</code> лучше использовать <code>checkinstall</code>? Эта утилита перехватит работу make, отследит куда ставятся все файлы приложения и создаст deb пакет для безопасной установки и удаления приложения.</p>

<p>Конфигурируется демон через редактирования файла <code>/etc/init.d/shairport-sync</code>, я там поменял только название сервиса. Обычно больше ничего не требуется для работы.</p>

<h3>Возможные проблемы</h3>

<p>При загрузке компьютера может появляться сообщение:</p>

<pre><code>Avahi detected that your currently configured local DNS server serves a domain .local. This is inherently incompatible with Avahi and thus Avahi disabled itself. If you want to use Avahi in this network, please contact your administrator and convince him to use a different DNS domain, since .local should be used exclusively for Zeroconf technology.
</code></pre>

<p>Работа Avahi будет останавливаться, соответственно и shairport не запустится. Обычно эта проблема связана с тем, что в DNS сервере есть записи для зоны local.</p>

<p>Проверяется это командой: <code>host -t SOA local.</code> (обратите внимание на точку в конце!). В нормальной ситуации вывод должен быть около такого: </p>

<pre><code>bash-3.2$ host -t SOA local.
Host local. not found: 3(NXDOMAIN)
</code></pre>

<p>Если же в выводе написано: <code>local has SOA record XXX</code>, то ваш DNS транслирует зону local. Обычно это делают провайдеры для работы сервисов типа retracker.local. Если вы этим не пользуетесь - можно просто указать днс Yandex (77.88.8.8/77.88.8.1) или Google(8.8.8.8/8.8.4.4).</p>

<p>После этих настроек и рестарта служб - все должно работать, а на устройствах Apple появится ваше устройство для вывода звука.</p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2015/05/02/elasticsearch-remove-messages/">Remove messages from Graylog2</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/graylog2/" rel="tag">graylog2</a>
                        <a href="/blog/tag/elasticsearch/" rel="tag">elasticsearch</a>
                    </p>

                    <aside>
                        <p><time datetime="2015-05-02">
                            Posted on 2015-05-02
                        </time>
                        </p>
                    </aside>

                </header>

                <p>If you want to remove all messages with requested pattern in message body, you have to write following line:</p>

<p>curl -XDELETE &#39;http://graylog.example:9200/graylog_*/message/_query&#39; -d&#39;{&quot;query&quot; : {&quot;match&quot;: { &quot;message&quot; : &quot;SearchPattern&quot;}}}&#39;</p>

<p>remove exact pattern:
curl -XDELETE &#39;http://graylog.example:9200/graylog_*/message/_query&#39; -d&#39;{&quot;query&quot; : {&quot;term&quot;: { &quot;message&quot; : &quot;ExactText&quot;}}}&#39;</p>



            </article>
            <article>
                <header>
                    <h1><a href="/blog/2015/04/30/using-perl-and-graylog/">Используем Graylog с Perl</a></h1>

                    <p class="tags">Tags:
                        <a href="/blog/tag/perl/" rel="tag">perl</a>
                        <a href="/blog/tag/graylog/" rel="tag">graylog</a>
                    </p>

                    <aside>
                        <p><time datetime="2015-04-30">
                            Posted on 2015-04-30
                        </time>
                        </p>
                    </aside>

                </header>

                <p>Устанавливаем Graylog. Для опытов я использовал преднастроенную VM для VirtualBox http://docs.graylog.org/en/1.0/pages/installation.html#virtual-machine-appliances</p>

<p>! На момент написания статьи в VM идет версия Graylog-web с багом - при создании dashboard на нее нельзя добавить виджет т.к. JS-скрипт ответственный за разблокировку dashboard падает с ошибкой. Что-бы что-то сделать с дэшбордом на него надо добавить любой виджет с любой страницы. Это делается по клику на иконку возле названия виджета и выбором нужного дэшборда.</p>

<p>Первым делом надо создать Input для логов.
Мы будем использовать GELF формат через Log::Log4perl.
Идем System-&gt;Inputs в выпадающем списке выбираем GELF UDP и жмем Launch Input.
В открывшемся окне выбираем ноды на которых будет работать этот инпут, описание, адрес на котором он будет слушать.
Жмем launch, убеждаемся что он стартанул и на этом пока все работы с Graylog закончены.</p>

<p>Теперь устанавливаем пакет <a href="https://metacpan.org/pod/Log::Log4perl::Layout::GELF">Log::Log4perl::Layout::GELF</a>.</p>

<p>Создаем файл конфигурации логгера:</p>

<pre><code>log4perl.logger.graylog                     = INFO, Screen, Graylog

log4perl.appender.Screen                = Log::Log4perl::Appender::Screen
log4perl.appender.Screen.stderr         = 0
log4perl.appender.Screen.layout         = Log::Log4perl::Layout::PatternLayout
log4perl.appender.Screen.layout.ConversionPattern = [%d] [%p] %m%n
log4perl.appender.Screen.utf8           = 1

log4perl.appender.Graylog          = Log::Log4perl::Appender::Socket
log4perl.appender.Graylog.PeerAddr = graylog.host
log4perl.appender.Graylog.PeerPort = 12201
log4perl.appender.Graylog.Proto    = udp
log4perl.appender.Graylog.layout   = GELF
</code></pre>

<p>Создаем тестовый скрипт:</p>

<pre><code>#!/usr/bin/env perl

use utf8;
use strict;
use Log::Log4perl;

#Загружаем конфигурацию 
Log::Log4perl::init(&#39;logger.conf&#39;);

#Получаем логгер
my $logger = Log::Log4perl-&gt;get_logger(&#39;graylog&#39;);

$logger-&gt;info(&#39;hello graylog&#39;);
$logger-&gt;info(&#39;Тестовое сообщение UTF8&#39;);
</code></pre>

<p>В теории, этого достаточно для того что бы нужные логи вашего приложения начали идти в Graylog. Но, как обычно, есть нюанс - этот модуль совершенно не представляет что есть более чем однобайтные кодировки и при попытке что-то записать в лог что-то с utf8 мы получим ошибку <code>Wide character in IO::Compress::Gzip::write</code> и в Graylog сообщение не придет.</p>

<p>Для обычных аппендеров, например Screen, эта проблема решается просто - дописываем в конфигурацию флаг включения utf8:</p>

<pre><code>log4perl.appender.FileAppndr.utf8     = 1
</code></pre>

<p>Но в данном случае проблема на уровне layout и этот модуль не обрабатывает такую ситуацию.</p>

<p>Для себя я эту проблему решил просто - сделал форк модуля с названием <a href="https://github.com/alpha6/Log-Log4perl-Layout-GELFUtf">GELFUtf</a> и использую его.</p>

<p>Таким образом в конфиге вместо <code>log4perl.appender.Graylog.layout   = GELF</code> пишу <code>log4perl.appender.Graylog.layout   = GELFUtf</code>.</p>

<p>Подменить фунцию на лету у меня не получилось, скорее всего из-за хитрой архитектуры Log4perl. А лезть патчить в рантайм - овчинка выделки не стоит. Так что пока пользуюсь патченым модулем и коплю силы на создание полноценного патча для оригинального модуля.</p>



            </article>
        </main>

        <ul class="pager">
            <li class="prev">
                <a class="button button-primary" href="/blog/page/2" rel="next">
                    ← Older
                </a>
            </li>
            <li class="next">
                <a class="button disabled" href="" rel="prev">
                    Newer →
                </a>
            </li>
        </ul>

    </div>

    <div class="three columns sidebar">
        
        <h1>Tags</h1>
        <ul class="list-inline">
            <li><a href="/blog/tag/Automation/">Automation</a></li>
            <li><a href="/blog/tag/LC_ALL/">LC_ALL</a></li>
            <li><a href="/blog/tag/Perl/">Perl</a></li>
            <li><a href="/blog/tag/Rex/">Rex</a></li>
            <li><a href="/blog/tag/Ubuntu/">Ubuntu</a></li>
            <li><a href="/blog/tag/airplay/">airplay</a></li>
            <li><a href="/blog/tag/bugs/">bugs</a></li>
            <li><a href="/blog/tag/elasticsearch/">elasticsearch</a></li>
            <li><a href="/blog/tag/gearman/">gearman</a></li>
            <li><a href="/blog/tag/graylog/">graylog</a></li>
            <li><a href="/blog/tag/graylog2/">graylog2</a></li>
            <li><a href="/blog/tag/io/">io</a></li>
            <li><a href="/blog/tag/linux/">linux</a></li>
            <li><a href="/blog/tag/note/">note</a></li>
            <li><a href="/blog/tag/package/">package</a></li>
            <li><a href="/blog/tag/perl/">perl</a></li>
            <li><a href="/blog/tag/shairport/">shairport</a></li>
            <li><a href="/blog/tag/snippet/">snippet</a></li>
            <li><a href="/blog/tag/ubuntu/">ubuntu</a></li>
        </ul>
        <h1>Feeds</h1>
        <ul class="list-inline">
            <li>
                <a href="/blog/index.atom" rel="alternate" type="application/atom+xml">
                    Atom
                </a>
            </li>
            <li>
                <a href="/blog/index.rss" rel="alternate" type="application/rss+xml">
                    RSS
                </a>
            </li>
        </ul>
    </div>

</div>

        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.github.io/Statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>
	<!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter7948447 = new Ya.Metrika({id:7948447, clickmap:true, trackLinks:true, accurateTrackBounce:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img alt="" src="//mc.yandex.ru/watch/7948447" style="position:absolute; left:-9999px;"></div></noscript><!-- /Yandex.Metrika counter -->
    </body>
</html>
