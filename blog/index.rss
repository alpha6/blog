<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Just another blog</title>
        <link>http://alpha6.ru/blog/</link>
        <atom:link href="http://alpha6.ru/blog/index.rss" rel="self" type="application/rss+xml" />
        <description>Blog feed of Just another blog</description>
        <generator>Statocles 0.077</generator>
        <item>
            <title>Работаем с самбой из Java с помощью JCIFS</title>
            <link>http://alpha6.ru/blog/2016/08/07/java-jcifs/</link>
            <guid>http://alpha6.ru/blog/2016/08/07/java-jcifs/</guid>
            <description><![CDATA[
                <h2>Простые примеры работы с самбой при помощи JCIFS</h2>

<p>Ниже показан пример класса для копирования файла на самба-шару и просмотра содержимого заданной шары</p>

<pre><code>import jcifs.Config;
import jcifs.smb.*;
import java.io.*;

public class SambaTest {
  // Нормальный конструктор я тут делать не буду, для тестового примера это не нужно
static final String USER_NAME = &quot;username&quot;;
static final String PASSWORD = &quot;password&quot;;
static final String DOMAIN = &quot;user_domain&quot;;

// Путь к сетевой папке с которой будем работать
static final String NETWORK_FOLDER = &quot;smb://server/share/&quot;;


// Копируем файл на шару.
// К сожалению SmbFile ничего не знает о методе copyTo из File,
// так что придется этот метод эмулировать руками. Халява не прокатила :(
// В обратную сторону все тоже самое, только потоки будут в обратную сторону.
public boolean copyFileToSamba(String srcFilePath, String destPath) {
    boolean successful = false;
    try{
        // Создаем объект аутентификатор
        NtlmPasswordAuthentication auth =
          new NtlmPasswordAuthentication(DOMAIN, USER_NAME, PASSWORD);

        // Читаем содержимое исходного файла
        File srcFile = new File(srcFilePath);
        InputStream localFile = new FileInputStream(srcFile);

        // Создаем объект для потока куда мы будем писать наша файл
        SmbFileOutputStream destFileName = new SmbFileOutputStream(
          new SmbFile(destPath+File.separator+srcFile.getName(), auth));

        // Ну и копируем все из исходного потока в поток назначения.
        BufferedReader brl = new BufferedReader(
          new InputStreamReader(localFile));
        String b = null;
        while((b=brl.readLine())!=null){
            destFileName.write(b.getBytes());
        }
        destFileName.flush();


        successful = true;
    } catch (Exception e) {
        successful = false;
        e.printStackTrace();
    }
    return successful;
}

// Читаем
public boolean readShareContent() {
    boolean successful = false;
    try{
        // Создаем объект для аутентификации на шаре
        NtlmPasswordAuthentication auth =
          new NtlmPasswordAuthentication(DOMAIN, USER_NAME, PASSWORD);
        String path = NETWORK_FOLDER;

        // Ресолвим путь назначения в SmbFile
        SmbFile baseDir = new SmbFile(path, auth);

        // Вычитываем все содержимое шары в массив
        SmbFile[] files = baseDir.listFiles();

        // Делаем что-нибудь со списком файлов
        for (int i = 0; i &lt; files.length; i++) {
          SmbFile file = files[i];
          if (file.isDirectory()) {
                System.out.println(&quot;Is DIR: &quot;+file.toString());
                continue;
          } else {
                System.out.println(&quot;Is FILE: &quot;+file.toString());
          }
        }

        successful = true;
    } catch (Exception e) {
        successful = false;
        e.printStackTrace();
    }
    return successful;
  }
}
</code></pre>

<p>Если все работы с шарой невероятно тупят - то нужно сменить режим ресолвинга сервера и шары.</p>

<p>В конструктор добавляем следующее:</p>

<pre><code>Config.setProperty( &quot;jcifs.resolveOrder&quot;, &quot;DNS&quot;);
</code></pre>

<p>Этим мы указываем что ресолвить имя сервера мы будем ТОЛЬКО через DNS. Можно туда добавить всякие NetBIOS и прочее, но на практике с необходимостью это делать я не сталкивался. Естественно, что если у вас в сети нет локального DNS сервера который будет ресолвить именя локальным машин - то механизм надо сменить на другой. Выбор механизмов ресолвинга будет проходить в порядке указанном в конфиге.</p>

                    <p><a href="http://alpha6.ru/blog/2016/08/07/java-jcifs/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/java/">java</a>
                    <a href="http://alpha6.ru/blog/tag/jcifs/">jcifs</a>
                    <a href="http://alpha6.ru/blog/tag/samba/">samba</a>
                </p>
            ]]></description>
            <pubDate>
                Sun, 07 Aug 2016 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Installing and configuring Postgresql 9.4 on Debian 8</title>
            <link>http://alpha6.ru/blog/2016/01/17/postgres-install/</link>
            <guid>http://alpha6.ru/blog/2016/01/17/postgres-install/</guid>
            <description><![CDATA[
                <p>Install the postgresql server package:</p>

<pre><code>#apt-get install postgresql-9.4
</code></pre>

<p>Create cluster (if it haven&#39;t created automatically):</p>

<pre><code>#pg_createcluster 9.4 main --start
</code></pre>

<p>Next we need to allow connects from remote sources.</p>

<p>Edit <code>/etc/postgresql/9.4/main/postgresql.conf</code> and set <code>listen_addresses</code> to <code>&#39;*&#39;</code>.</p>

<p>Restart the Postgresql service:</p>

<pre><code>#service postgresql Restart
</code></pre>

<p>Now we should create database user.</p>

<pre><code>#su postgres
#psql

postgres=# CREATE USER db_user_name WITH PASSWORD &#39;secret_password&#39;;
</code></pre>

<p>Create new database and grant access to it to our user.</p>

<pre><code>postgres=# CREATE DATABASE &quot;db_name&quot;
  WITH OWNER &quot;db_user_name&quot;
  ENCODING &#39;UTF8&#39;
  LC_COLLATE = &#39;en_US.UTF-8&#39;
  LC_CTYPE = &#39;en_US.UTF-8&#39;
  TEMPLATE = template0;
</code></pre>

<p>Now we have database with UTF8 collation, it is time to allow connect from remote sources. Our user is the owner of the schema.</p>

<p>Edit <code>/etc/postgresql/9.4/main/pg_hba.conf</code> and add line</p>

<pre><code>host    all   db_user_name    0.0.0.0/0               md5
</code></pre>

<p>after the line:</p>

<pre><code>host    all   all             127.0.0.1/32            md5
</code></pre>

<p>Save file and restart the service.</p>

<p>Now we can connect to our server from remote computer.</p>

                    <p><a href="http://alpha6.ru/blog/2016/01/17/postgres-install/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/postgresql/">postgresql</a>
                    <a href="http://alpha6.ru/blog/tag/debian/">debian</a>
                </p>
            ]]></description>
            <pubDate>
                Sun, 17 Jan 2016 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>git clone recursive</title>
            <link>http://alpha6.ru/blog/2015/12/28/git-clone-recursive/</link>
            <guid>http://alpha6.ru/blog/2015/12/28/git-clone-recursive/</guid>
            <description><![CDATA[
                <p>В Git 2.6 для Windows появилась неприятная бага - если уровень вложенности сабмодулей больше 3х, то команда <code>git clone --recursive</code> падает с ошибкой при клонировании глубоко вложенных сабмодулей.</p>

<p>Как бороться - разбить клонирование на 3 этапа:</p>

<pre><code>git clone &lt;repo_addr&gt;
cd &lt;repo_dir&gt;
git submodule update --init
git submodule foreach --recursive git submodule update --init
</code></pre>

<p>Здесь мы просто клонируем репозиторий, при необходимости можно сделать чекаут на нужную ветку.
Затем инициализируем и загружаем сабмодули первого уровня. И последняя команда проходит рекурсивно по всем сабмодулям рекурсивно и загружает их на неограниченном (наверное) уровне вложенности.</p>

                    <p><a href="http://alpha6.ru/blog/2015/12/28/git-clone-recursive/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/git/">git</a>
                    <a href="http://alpha6.ru/blog/tag/windows/">windows</a>
                </p>
            ]]></description>
            <pubDate>
                Mon, 28 Dec 2015 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>State переменные в Perl</title>
            <link>http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/</link>
            <guid>http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/</guid>
            <description><![CDATA[
                <p>В Perl существует особый тип переменных под названием state.</p>

<p>В <a href="http://perldoc.perl.org/functions/state.html">доке</a> про них написано:</p>

<blockquote>
  <p>state declares a lexically scoped variable, just like my. However, those variables will never be reinitialized ...</p>
</blockquote>

<p>На первый взгляд это дает нам возможность очень просто реализовывать счетчики и иже с ними:</p>

<pre><code>sub count {
  state $count = 0;
  $count++;
}
</code></pre>

<p>Однако, есть нюанс - фраза <em>will never be reinitialized</em> означает что переменная действительно никогда не будет переинициализирована пока существует родительский скрипт. И это дает нам вот такую замечательную граблю на которую можно ненароком наступить:</p>

<p>Объявляем пакет:</p>

<pre><code>package MyTestState;

use strict;
use feature &#39;state&#39;;

sub new {
  bless {}, shift;
}

sub count {
  state $count = 0;
  $count++;
}

1;
</code></pre>

<p>И саму программу:</p>

<pre><code>use lib &#39;lib&#39;;
use v5.18;
use MyTestState;

my $mystate =  MyTestState-&gt;new();

for (0..10) {
  my $counter = $mystate-&gt;count();
  say &quot;Counter [$counter]&quot;;
}
</code></pre>

<p>Вывод ожидаем:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
</code></pre>

<p>А теперь добавляем такой код:</p>

<pre><code>undef $mystate;

say &quot;next object!=======&quot;;

my $mystate1 = MyTestState-&gt;new();
for (0..10) {
  my $counter = $mystate1-&gt;count();
  say &quot;Counter [$counter]&quot;;

}
</code></pre>

<p>Здесь мы удаляем старый объект со счетчиком и создаем новый. Логично предположить что счетчик пойдет заново, но на самом деле нет. Не смотря на то что мы удалили старый объект и создали новый, переменная со счетчиком никуда не делась и не была переиницализирована! И при запуске программы мы увидим:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
next object!
Counter [11]
Counter [12]
Counter [13]
...
Counter [20]
Counter [21]
</code></pre>

<p>Так что слово <code>newer</code> в документации действительно значит &quot;никогда пока жив инстанс интерпретатора запустивший скрипт&quot;.</p>

                    <p><a href="http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/state/">state</a>
                    <a href="http://alpha6.ru/blog/tag/trap/">trap</a>
                </p>
            ]]></description>
            <pubDate>
                Sat, 26 Dec 2015 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Spotlight does not search for</title>
            <link>http://alpha6.ru/blog/2015/12/23/not-seeking-spotlight/</link>
            <guid>http://alpha6.ru/blog/2015/12/23/not-seeking-spotlight/</guid>
            <description><![CDATA[
                <p>If your Spotlight does not search for some files or applications:</p>

<p>The first of all - restart the Spotlight:</p>

<pre><code>sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist
sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist
</code></pre>

<p>If it have no effect - remove Spotlight&#39;s index:</p>

<p>Stop Spotlight service:</p>

<pre><code>sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist
</code></pre>

<p>Remove Spotlight index folder:</p>

<pre><code>sudo rm -rf /.Spotlight-V100
</code></pre>

<p>Run service:</p>

<pre><code>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist
</code></pre>

<p>After reindex - everything should work well.</p>

                    <p><a href="http://alpha6.ru/blog/2015/12/23/not-seeking-spotlight/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/spotlight/">Spotlight</a>
                    <a href="http://alpha6.ru/blog/tag/elcapitan/">ElCapitan</a>
                    <a href="http://alpha6.ru/blog/tag/macos/">MacOS</a>
                </p>
            ]]></description>
            <pubDate>
                Wed, 23 Dec 2015 00:00:00 +0000
            </pubDate>
        </item>
    </channel>
</rss>

