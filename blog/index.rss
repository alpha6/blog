<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Just another blog</title>
        <link>http://alpha6.ru/blog/</link>
        <atom:link href="http://alpha6.ru/blog/index.rss" rel="self" type="application/rss+xml" />
        <description>Blog feed of Just another blog</description>
        <generator>Statocles 0.077</generator>
        <item>
            <title>Добавляем второй экструдер к RAMPS 1.4/Marlin</title>
            <link>http://alpha6.ru/blog/2016/09/04/marlin-adding-second-extruder/</link>
            <guid>http://alpha6.ru/blog/2016/09/04/marlin-adding-second-extruder/</guid>
            <description><![CDATA[
                <p>В прошлой серии мы установили прошивку Marin и откалибровали все это дело. Теперь пришло время добавить второй экструдер.</p>

<p>Для этого нам понадобится:</p>

<ul>
<li>второй экструдер</li>
<li>второй хот-энд в сборе и все прилегающие детали, типа трубки боудена</li>
<li>каретка на два экструдера. Я использую <a href="http://www.thingiverse.com/thing:1749633">такую</a>.</li>
</ul>

<p>В общем случае все просто идем в Arduino IDE и правим конфигурацию.</p>

<p>Меняем конфигурацию платы управления на RAMPS 1.4 c 2 экструдерами и подогреваемым столом</p>

<pre><code>#ifndef MOTHERBOARD
  #define MOTHERBOARD BOARD_RAMPS_14_EEB
#endif
</code></pre>

<p>Указываем кол-во экструдеров:</p>

<pre><code>#define EXTRUDERS 2
</code></pre>

<p>Указываем тип датчика температуры для второго экструдера:</p>

<pre><code>#define TEMP_SENSOR_1 1
</code></pre>

<p>Максимальную температуру:</p>

<pre><code>#define HEATER_1_MAXTEMP 250
</code></pre>

<p>Если надо, устанавливаем направление вращения мотора:</p>

<pre><code>#define INVERT_E1_DIR true
</code></pre>

<p>В целом, если у вас одинаковые моторы на обоих экструдерах, то на этом настройка закончена.</p>

<p>Но если у моторы разные или  на одном экструдере у меня мотор с шестерней подачи диаметром 10мм, а на втором - 7мм, то тут начинаются проблемы с калибровкой.</p>

<p>Как откалибровать второй экструдер?
Идем в пронтерфейс и говорим:</p>

<pre><code>T1
</code></pre>

<p>Эта команда указывает что сейчас активен экструдер номер 2 (отсчет начинается с 0). Включаем подачу филамента, для подачи будет использоваться число шагов из прошивки, т.е. для первого экструдера. Смотрим разницу и с помощью пропорции получаем кол-во шагов для активного экструдера. У меня из-за разницы в подающих шестернях получилось 80 шагов на мм.</p>

<p>Говорим:</p>

<pre><code>M92 E80
</code></pre>

<p>Этим мы устанавливаем новое кол-во шагов для текущего экструдера. Проверяем, при необходимости подгоняем значение.</p>

<p>После калибровки вылезает проблема - Marlin не поддерживает установку разного числа шагов для разных экструдеров, соответственно в прошивке нам эти данные не сохранить. Придется этот вопрос решать програмно.</p>

<p>Идем в <code>Slic3r</code>, я, в основном, использую его, для других слайсеров будут отличия. Переходим на вкладку <code>Printer Setting -&gt; Custom G-Code</code>.
Нас интересует поле <code>Tool change G-Code</code>. Код в этом поле будет вызываться при каждой смене экструдера.
Пишем туда следующее:</p>

<pre><code>[[previous_extruder==0]]
M92 E80
[[/previous_extruder==0]]
[[previous_extruder==1]]
M92 E95
[[/previous_extruder==1]]
</code></pre>

<p>Этот макрос дает следующий эффект - если мы переключились с экструдера 1, то выставляем число шагов текущего экструдера (второго) равным значению которое мы получили при калибровке, в моем случае это 80.
Если мы переключились со второго экструдера на первый - то выставляем для него значение числа шагов равное значению из прошивки.</p>

<p>Дальше идем в <code>Extruder 2</code> и выставляем смещение. Если вся эта конструкция собрана на каретке ссылку на которую я давал выше - то смещение по оси X  будет 24, по Y - 0. Для других кареток надо мерять и выставлять фактические значения.</p>

<p>После этого печатаем деталь для <a href="http://www.thingiverse.com/thing:124450">калибровки 2х экструдеров</a> и точно подгоняем все для идеальной работы.</p>

                    <p><a href="http://alpha6.ru/blog/2016/09/04/marlin-adding-second-extruder/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/prusai3/">prusai3</a>
                    <a href="http://alpha6.ru/blog/tag/marlin/">marlin</a>
                    <a href="http://alpha6.ru/blog/tag/slic3r/">Slic3r</a>
                </p>
            ]]></description>
            <pubDate>
                Sun, 04 Sep 2016 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Настраиваем прошивку Marlin для Arduino + RAMPS 1.4</title>
            <link>http://alpha6.ru/blog/2016/08/23/marlin-setup/</link>
            <guid>http://alpha6.ru/blog/2016/08/23/marlin-setup/</guid>
            <description><![CDATA[
                <p>Так получилось что некоторое время назад я стал владельцем китайского клона Prusa i3 под гордым китайским названием Hesine M505.
Это чудо китайской мысли конечно было далеко от совершенства, но с задачей печатать все подряд справлялось вполне успешно. Однако, чем дальше в лес - тем толще партизаны. И забравшись в лес подальше возжелал я печатать детали с использованием растворимых поддержек, да и двумя цветами печатать тоже было бы  неплохо.</p>

<p>К сожалению, у родной для принтера платы Melzi V2 был фатальный недостаток - на ней отсутсвовал порт для подключения второго экструдера. Изучение матчасти показало, что можно взять еще одну такую же плату и воткнуть ее в режиме слейва. Однако ценник на это удовольствие получался высоковатым. И, что самое неприятно, при таком апгрейде терялась возможность подключения экрана и кнопок управления. Т.е. печатать можно будет только с компьютера, а это не самая лучшая идея по многим причинам.</p>

<p>Так я пришел к решению полностью заменить мозги принтера. Выбор был сделан в пользу нестареющей класски Arduino Mega 2560 + RAMPS 1.4 + A4988. Быстро сказка сказывается, да долго посылочка едет. Получив посылку с мозгами, моторами и прочим полезным в хозяйстве инвентарем я обнаружил что забыл заказать шестерню податчика экструдера. Благо на тот момент она уже ехала ко мне с али, где я заказал ее просто так, от жадности.</p>

<p>В общем, пока необходимые запчасти едут, можно подключить и отстроить новые мозги в конфигурации с одним экструдером, а потом просто переконфигурировать прошивку когда будет собрано все железо.</p>

<p>Ставить мы будем классику жанра - Marlin. Клонируем репозиторий в любое удобное место отсюда https://github.com/MarlinFirmware/Marlin. Скачиваем Arduino IDE.</p>

<p>В Arduino IDE открываем прошивку.
Выбираем нашу плату Arduino Mega 2560 и процессор AtMega 2560.</p>

<p>Дальше нас интересует вкладка с файлом Configuration.h, теперь мы будем его безудержно править.</p>

<p>Выбираем нашу плату: RAMPS 1.4 с одним хотэндом</p>

<pre><code>#ifndef MOTHERBOARD
  #define MOTHERBOARD BOARD_RAMPS_14_EFB
#endif
</code></pre>

<p>В файле boards.h приведен полный список поддерживаемых плат и их вариаций. Нас пока интересует только RAMPS 1.4 с одним экструдером.</p>

<p>Выставляем кол-во температурных сенсоров. Сенсоров должно быть по числу экструдеров. В нашем случае 1. Убеждаемся что напротив первого сенсора в списке стоит 1.</p>

<pre><code>#define TEMP_SENSOR_0 1
</code></pre>

<p>Выставляем максимальную температуру хотэнда и стола.</p>

<pre><code>#define HEATER_0_MAXTEMP 250
#define BED_MAXTEMP 130
</code></pre>

<p>У меня стоят термопредохранители на 252 градуса, так что максимальная температура хота должна быть ниже температуры срабатывания предохранителя. Если собираетесь печатать чем-то вроде поликарбоната - то температуру надо поднять. Со столом таже история, единственное что даже печать нейлоном не требует очень больших температур стола, 130 градусов должно хватить всем.</p>

<p>В Hesine M505 стоят нормально замкнутые концевики, а в прошивка по умолчанию рассчитывает на нормально разомкнутые.
Включаем инвертирование концевиков:</p>

<pre><code>// Mechanical endstop with COM to ground and NC to Signal uses &quot;false&quot; here (most common setup).
#define X_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
#define Y_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
#define Z_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
</code></pre>

<p>Проверяем направление вращения моторов. Тут история примерно таже что и с концевиками, т.к. прошивка изначально рассчитана на Ultimaker.</p>

<pre><code>// Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
#define INVERT_X_DIR true
#define INVERT_Y_DIR true
#define INVERT_Z_DIR false
</code></pre>

<p>И для экструдера повторяем операцию.</p>

<pre><code>#define INVERT_E0_DIR true
</code></pre>

<p>Выставляем размеры рабочей зоны</p>

<pre><code>#define X_MIN_POS 0
#define Y_MIN_POS 0
#define Z_MIN_POS 0
#define X_MAX_POS 250
#define Y_MAX_POS 230
#define Z_MAX_POS 140
</code></pre>

<p>Для начала можно выставить заводомо большие чем рабочая зона габариты. Потом все откалибруется по месту. По умолчанию в прошивке стоят значени 200х200х200, тогда как у Hesine M505 рабочее поле по всем направлениям больше чем эти цифры. И прошивка просто не даст двигаться за их пределы.</p>

<p>Устанавливаем координаты начала стола. Это нужно чтобы ноль стола в слайсере совпадал с нулем в координатах принтера. Иначе модель может вылезать за пределы зоны печати.</p>

<pre><code>#define MANUAL_X_HOME_POS -30
#define MANUAL_Y_HOME_POS -20
</code></pre>

<p>Выставляем шаги для моторов.</p>

<pre><code>#define DEFAULT_AXIS_STEPS_PER_UNIT   {100,100,1600,95}
</code></pre>

<p>Параметры тут следующие: мотор_Х, мотор_Y, мотор_Z, мотор_экструдера</p>

<p>Для рассчета шагов по X и Y используем следующую формулу:</p>

<pre><code>(200*16)/(16*2)=80 шагов
</code></pre>

<p>Где 200 - это число шагов двигателя на 360 градусов. Типичная цифра для моторов с шагом 1.8 градуса.
16 в числителе - кол-во микрошагов на шаг.
16 в знаменателе - кол-во зубов на шпуле.
2 - стандартный шаг для ремня GT2</p>

<p>Для Z:</p>

<pre><code>3200/2 = 1600
</code></pre>

<p>В Hesine M505 штатно используется трапециидальный винт с шагом резьбы 2мм. Соответственно мы белим число шагов на полный оборот на кол-во миллиметров которые будут пройдены за оборот и получаем число шагов на миллиметр.</p>

<p>Подачу экструдера пока посчитаем и выставим предварительно. Потом ее все равно придется подгонять.
Шестерня экструдера штатно имеет диаметр около 10мм. Получаем длинну окружности на один оборот: 3.14*10=31.4 мм на оборот.</p>

<p>Делим число шагов на длинну окружности и получаем число шагов на миллиметр.</p>

<pre><code>3200/31.4=101.9
</code></pre>

<p>округляем до 102.</p>

<p>Заливаем все это дело в Arduino.</p>

<p>После того как все залилось и все железо подключено запускаем Pronterface и начинаем калибровку.</p>

<ul>
<li>Двигаем моторы и проверяем что они крутятся в нужную сторону. Если это не так - меняем параметр INVERT_*_DIR на противоположное значение.</li>
<li>Проверяем состояние концевиков. По команде M119 будет показано состояние концевиков. Если концевик нажат - напротив него должно быть написано TRIGGERED. Напротив ненажатого - open. Если это не так - меняем настройку *<em>MIN</em>ENDSTOP_INVERTING.</li>
<li>Даем команду G28. Все оси должны приехать в свое минимальное положение. Дальше через Pronterface двигаем все оси в их безопасное максимальное положение и даем комаду M114. Она покажет текущее положение по осям. Вносим эти данные в настройку *<em>MAX</em>POS.</li>
<li>Опять говорим G28. Передвигаем экструдер в нулевую координату стола по X-Y. Смотрим что показывает M114 и эти цифры переносим в MANUAL_*<em>HOME</em>POS с обратным знаком. Т.е. если M114 говорит что координата по Х сейчас 30 - то в настройку пишем -30. Это значит что после ухода в HOME экструдер отъедет от него на 30мм и будет считать это положение нолем.</li>
<li>откручиваем сопло или трубку боудена у экструдера. На прутке отмечаем расстояние, например 10 см, и прогоняем эту же длинну из Pronterface. После этого смотрим сколько в реальности прошло прутка и корректируем кол-во шагов для экструдера чтобы он прогонял четко нужное кол-во пластика. Важно понимать что на горячую с установленным соплом эта цифра все равно будет отличаться от установленного. Если вы всегда печатаете соплом одного диаметра - можно повторить эту операцию с соплом и полученные данные внести в прошивку. Я использую несколько сопел, так что объем пластика корректирую через настройку потока в слайсере.</li>
</ul>

<p>После того как все это сделано - печатаем тестовую модель. Я использую пустой куб 20х20х20 мм. После того как он отпечатан - проверяем что размеры сторон у нас точно соответсвуют тому что должно быть. Если это не так по отдельным измерениям - корректируем кол-во шагов для нужной оси.</p>

<p>На этом основные настройки закончены. Дальше можно тюнить приведенные выше параметры для более качественной печати.</p>

                    <p><a href="http://alpha6.ru/blog/2016/08/23/marlin-setup/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/prusai3/">prusai3</a>
                    <a href="http://alpha6.ru/blog/tag/3dprinting/">3dprinting</a>
                    <a href="http://alpha6.ru/blog/tag/ramps/">ramps</a>
                    <a href="http://alpha6.ru/blog/tag/marlin/">marlin</a>
                </p>
            ]]></description>
            <pubDate>
                Tue, 23 Aug 2016 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Работаем с самбой из Java с помощью JCIFS</title>
            <link>http://alpha6.ru/blog/2016/08/07/java-jcifs/</link>
            <guid>http://alpha6.ru/blog/2016/08/07/java-jcifs/</guid>
            <description><![CDATA[
                <h2>Простые примеры работы с самбой при помощи JCIFS</h2>

<p>Ниже показан пример класса для копирования файла на самба-шару и просмотра содержимого заданной шары</p>

<pre><code>import jcifs.Config;
import jcifs.smb.*;
import java.io.*;

public class SambaTest {
  // Нормальный конструктор я тут делать не буду, для тестового примера это не нужно
static final String USER_NAME = &quot;username&quot;;
static final String PASSWORD = &quot;password&quot;;
static final String DOMAIN = &quot;user_domain&quot;;

// Путь к сетевой папке с которой будем работать
static final String NETWORK_FOLDER = &quot;smb://server/share/&quot;;


// Копируем файл на шару.
// К сожалению SmbFile ничего не знает о методе copyTo из File,
// так что придется этот метод эмулировать руками. Халява не прокатила :(
// В обратную сторону все тоже самое, только потоки будут в обратную сторону.
public boolean copyFileToSamba(String srcFilePath, String destPath) {
    boolean successful = false;
    try{
        // Создаем объект аутентификатор
        NtlmPasswordAuthentication auth =
          new NtlmPasswordAuthentication(DOMAIN, USER_NAME, PASSWORD);

        // Читаем содержимое исходного файла
        File srcFile = new File(srcFilePath);
        InputStream localFile = new FileInputStream(srcFile);

        // Создаем объект для потока куда мы будем писать наша файл
        SmbFileOutputStream destFileName = new SmbFileOutputStream(
          new SmbFile(destPath+File.separator+srcFile.getName(), auth));

        // Ну и копируем все из исходного потока в поток назначения.
        BufferedReader brl = new BufferedReader(
          new InputStreamReader(localFile));
        String b = null;
        while((b=brl.readLine())!=null){
            destFileName.write(b.getBytes());
        }
        destFileName.flush();


        successful = true;
    } catch (Exception e) {
        successful = false;
        e.printStackTrace();
    }
    return successful;
}

// Читаем
public boolean readShareContent() {
    boolean successful = false;
    try{
        // Создаем объект для аутентификации на шаре
        NtlmPasswordAuthentication auth =
          new NtlmPasswordAuthentication(DOMAIN, USER_NAME, PASSWORD);
        String path = NETWORK_FOLDER;

        // Ресолвим путь назначения в SmbFile
        SmbFile baseDir = new SmbFile(path, auth);

        // Вычитываем все содержимое шары в массив
        SmbFile[] files = baseDir.listFiles();

        // Делаем что-нибудь со списком файлов
        for (int i = 0; i &lt; files.length; i++) {
          SmbFile file = files[i];
          if (file.isDirectory()) {
                System.out.println(&quot;Is DIR: &quot;+file.toString());
                continue;
          } else {
                System.out.println(&quot;Is FILE: &quot;+file.toString());
          }
        }

        successful = true;
    } catch (Exception e) {
        successful = false;
        e.printStackTrace();
    }
    return successful;
  }
}
</code></pre>

<p>Если все работы с шарой невероятно тупят - то нужно сменить режим ресолвинга сервера и шары.</p>

<p>В конструктор добавляем следующее:</p>

<pre><code>Config.setProperty( &quot;jcifs.resolveOrder&quot;, &quot;DNS&quot;);
</code></pre>

<p>Этим мы указываем что ресолвить имя сервера мы будем ТОЛЬКО через DNS. Можно туда добавить всякие NetBIOS и прочее, но на практике я с необходимостью это делать не сталкивался. Естественно, что если у вас в сети нет локального DNS сервера который будет ресолвить именя локальным машин - то механизм надо сменить на другой. Выбор механизмов ресолвинга будет проходить в порядке указанном в конфиге.</p>

<p>Если предполагается копирование больших бинарных файлов, то код копирования надо заменить с:</p>

<p>BufferedReader brl = new BufferedReader(new InputStreamReader(localFile));
  String b = null;
  while((b=brl.readLine())!=null){
    destFileName.write(b.getBytes());
  }</p>

<p>на:</p>

<p>byte[] buffer = new byte[1024000];
  int noOfBytes = 0;</p>

<p>while ((noOfBytes = localFile.read(buffer)) != -1) {
    destFileName.write(buffer, 0, noOfBytes);
  }</p>

<p>Если этого не сделать - то большие файлы будут копироваться криво.</p>

                    <p><a href="http://alpha6.ru/blog/2016/08/07/java-jcifs/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/java/">java</a>
                    <a href="http://alpha6.ru/blog/tag/jcifs/">jcifs</a>
                    <a href="http://alpha6.ru/blog/tag/samba/">samba</a>
                </p>
            ]]></description>
            <pubDate>
                Sun, 07 Aug 2016 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Installing and configuring Postgresql 9.4 on Debian 8</title>
            <link>http://alpha6.ru/blog/2016/01/17/postgres-install/</link>
            <guid>http://alpha6.ru/blog/2016/01/17/postgres-install/</guid>
            <description><![CDATA[
                <p>Install the postgresql server package:</p>

<pre><code>#apt-get install postgresql-9.4
</code></pre>

<p>Create cluster (if it haven&#39;t created automatically):</p>

<pre><code>#pg_createcluster 9.4 main --start
</code></pre>

<p>Next we need to allow connects from remote sources.</p>

<p>Edit <code>/etc/postgresql/9.4/main/postgresql.conf</code> and set <code>listen_addresses</code> to <code>&#39;*&#39;</code>.</p>

<p>Restart the Postgresql service:</p>

<pre><code>#service postgresql Restart
</code></pre>

<p>Now we should create database user.</p>

<pre><code>#su postgres
#psql

postgres=# CREATE USER db_user_name WITH PASSWORD &#39;secret_password&#39;;
</code></pre>

<p>Create new database and grant access to it to our user.</p>

<pre><code>postgres=# CREATE DATABASE &quot;db_name&quot;
  WITH OWNER &quot;db_user_name&quot;
  ENCODING &#39;UTF8&#39;
  LC_COLLATE = &#39;en_US.UTF-8&#39;
  LC_CTYPE = &#39;en_US.UTF-8&#39;
  TEMPLATE = template0;
</code></pre>

<p>Now we have database with UTF8 collation, it is time to allow connect from remote sources. Our user is the owner of the schema.</p>

<p>Edit <code>/etc/postgresql/9.4/main/pg_hba.conf</code> and add line</p>

<pre><code>host    all   db_user_name    0.0.0.0/0               md5
</code></pre>

<p>after the line:</p>

<pre><code>host    all   all             127.0.0.1/32            md5
</code></pre>

<p>Save file and restart the service.</p>

<p>Now we can connect to our server from remote computer.</p>

                    <p><a href="http://alpha6.ru/blog/2016/01/17/postgres-install/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/postgresql/">postgresql</a>
                    <a href="http://alpha6.ru/blog/tag/debian/">debian</a>
                </p>
            ]]></description>
            <pubDate>
                Sun, 17 Jan 2016 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>git clone recursive</title>
            <link>http://alpha6.ru/blog/2015/12/28/git-clone-recursive/</link>
            <guid>http://alpha6.ru/blog/2015/12/28/git-clone-recursive/</guid>
            <description><![CDATA[
                <p>В Git 2.6 для Windows появилась неприятная бага - если уровень вложенности сабмодулей больше 3х, то команда <code>git clone --recursive</code> падает с ошибкой при клонировании глубоко вложенных сабмодулей.</p>

<p>Как бороться - разбить клонирование на 3 этапа:</p>

<pre><code>git clone &lt;repo_addr&gt;
cd &lt;repo_dir&gt;
git submodule update --init
git submodule foreach --recursive git submodule update --init
</code></pre>

<p>Здесь мы просто клонируем репозиторий, при необходимости можно сделать чекаут на нужную ветку.
Затем инициализируем и загружаем сабмодули первого уровня. И последняя команда проходит рекурсивно по всем сабмодулям рекурсивно и загружает их на неограниченном (наверное) уровне вложенности.</p>

                    <p><a href="http://alpha6.ru/blog/2015/12/28/git-clone-recursive/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/git/">git</a>
                    <a href="http://alpha6.ru/blog/tag/windows/">windows</a>
                </p>
            ]]></description>
            <pubDate>
                Mon, 28 Dec 2015 00:00:00 +0000
            </pubDate>
        </item>
    </channel>
</rss>

