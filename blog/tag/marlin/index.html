<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <link href="/theme/css/skeleton.css" rel="stylesheet">
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Just another blog</title>
        <meta content="Statocles 0.083" name="generator">
        <link href="/blog/tag/marlin.atom" rel="alternate" type="application/atom+xml">
        <link href="/blog/tag/marlin.rss" rel="alternate" type="application/rss+xml">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/">Just another blog</a>
                    <ul>
                        <li>
                            <a href="/">Blog</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <div class="row">
                <div class="nine columns">
                    <main>
                        

<article>
    <header>
        <h1><a href="/blog/2017/02/09/rostock-autolevel/">Автоматическая калибровка на датчике веса на примере Rostock mini</a></h1>

        <aside>
            <time datetime="2017-02-09">
                Posted on 2017-02-09
            </time>
            <a data-disqus-identifier="/2017/02/09/rostock-autolevel/index.markdown" href="/blog/2017/02/09/rostock-autolevel/#disqus_thread">0 comments</a>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/3d-printer/" rel="tag">3d-printer</a>
            <a href="/blog/tag/melzi/" rel="tag">melzi</a>
            <a href="/blog/tag/marlin/" rel="tag">marlin</a>
            <a href="/blog/tag/rostock/" rel="tag">rostock</a>
            <a href="/blog/tag/autolevel/" rel="tag">autolevel</a>
            <a href="/blog/tag/weight-sensor/" rel="tag">weight sensor</a>
        </p>

    </header>

    <p>Во всех моих 3д-принтерах меня каждый раз неимоверно бесила необходимость выставлять высоту сопла над уровнем стола. Необходимость эта возникала регулярно, при каждой замене сопла или каких-то других действиях с хотэндом, требовавших его разборки.</p>

<p>Периодически я видел всякие конструкции на базе датчиков приближения (холла), оптических датчиков и прочих шайтан-машин. Но все они требовали точно так же выставлять уровень сопла после каких-либо манипуляций с хотом. Правда, теперь уровень задавался относительно датчика, а не стола. Но радости это все равно не приносило.</p>

<p>Проблему решать надо было кардинально. Для этого нужно, чтобы в качестве датчика уровня использовалось само сопло.</p>

<p>Первое и самое очевидное решение - кинуть один провод на хот, второй на стол, и все это дело завсести на пины концевика. Надежное и дешевое решение, если у вас стол из алюминия без покрытия. У меня на столе лежит зеркало, и такой способ мне не подходит.</p>

<p>Второй способ был - поставить микрик на каретку так, чтобы касание соплом стола вызывало срабатывание микрика. Способ рабочий, но у меня не получилось избавиться от люфтов в креплении хот-энда, и я от него отказался.</p>

<p>Затем на просторах ютуба я увидел, как работает автоматическая калибровка на датчике веса. Правда, там пленочные датчики крепились на стол, но быстрый поиск по запасникам алиэкспресса выдал металлические датчики в виде брусков, на которые уже можно повесить хот-энд.</p>

<p>Я заказал <a href="http://alipromo.com/redirect/cpa/o/ol4k5ubfoept22yoak4cceyn43ykeuok/">модуль АЦП HX711</a> и сам <a href="http://alipromo.com/redirect/cpa/o/ol4k7ueyxqvue32fhvhmfy8n830yd08f/">датчик на 1кг</a>. Спустя месяц ожидания все это дело было получено и настало время прикрутить эту красоту к принтеру.</p>

<p>Есть два варианта подключения. Первый - это подключить АЦП напрямую к мозгам принтера и сказать прошивке, что это датчик веса. Но это решение, на мой взгляд, сильно так себе. Во-первых, поддержка таких датчиков находится пока только в экспериментальном состоянии. Во-вторых, мозгам и так есть чем заняться помимо того, чтобы постоянно читать вес от датчика и пытаться понять, что там происходит.
Значит нам нужен второй вариант: подключить это через промежуточный контроллер, который будет прикидываться концевиком для мозгов принтера. Его и выберем.</p>

<p>План действий будет следующий:</p>

<ul>
<li>Печатаем крепления датчика на эффектор</li>
<li>Подключаем датчик веса к Arduino</li>
<li>Подключаем Arduino с датчиком к мозгам принтера</li>
<li>Редактируем прошивку принтера.</li>
</ul>

<p>Крепления можно скачать <a href="http://www.thingiverse.com/thing:2102961">тут</a>. Вариант сыроватый, но рабочий и дорабатываемый по мере выявления недостатков.</p>

<p>Теперь подключаем контроллер к АЦП. Я нарыл в закромах Arduino Nano, но это не принципиально. На время отладки и калибровки сойдет и так, а дальше я поменяю на Attiny13, которая будет монтироваться вместе с платой АЦП прямо на эффектор для уменьшения уровня наводок по всем этим трактам. Почему на эффектор, а не рядом с основными мозгами принтера? Потому что для наилучшей точности стоит максимально укоротить провода между АЦП и датчиком веса. А если мы монтируем туда АЦП, то есть смысл прицепить туда и контроллер, чтобы от эффектора просто вести три провода к мозгам.</p>

<p>Также с этим АЦП есть нюанс: по умолчанию частота выборок АЦП составляет 10Гц, что слишком мало для нашего применения. То есть, технически, будет работать и так, но точность срабатывания будет плохой.
Для нормальной работы надо перевести АЦП в режим частоты опроса 80Гц. Для этого надо отцепить ногу <code>RATE</code> от земли и посадить ее на VCC.
<img alt="HX711 schema" src="/static/img/hx711/HX711-schema.jpg"></p>

<p>Тут есть два варианта, зависят от ревизии платы HX711.</p>

<p>Вариант с новой ревизией - просто запаиваем перемычку на слева от которой написано 80Hz.
<img alt="HX711 new" src="/static/img/hx711/HX711-2.jpg"></p>

<p>Если не повезло и пришла старая ревизия, то надо отпаять от платы вторую сверху ногу со стороны 4х-пинового разъема и подпаять ее к VCC или первой сверху ноге.
 <img alt="HX711 old" src="/static/img/hx711/HX711-1.jpg"></p>

<p>Все, модуль переключен в режим опроса 80Гц и наша жизнь стала немного прекраснее.</p>

<p>Зачем это проделывать? Так как показания датчика нестабильны из-за наличия вентилятора на голове и постоянных движений эффектора в процессе калибровки, то в скетче используется фильтр НЧ, который сглаживает скачки показаний датчика для большей надежности работы. Фильтр берет 10 значений веса и из них получает отфильтрованные показания. На частоте 80Гц выборка 10 значений занимает примерно 120мс, на частоте 10Гц - займет секунду. Соответственно, надо жертвовать фильтром, что будет приводить к ложным срабатываниям во время движения головы.</p>

<p>Подключаем датчик к АЦП. Соединяем провода:</p>

<ul>
<li>Красный -&gt; E+</li>
<li>Черный  -&gt; E-</li>
<li>Белый   -&gt; A-</li>
<li>Зеленый -&gt; A+</li>
</ul>

<p>Подключаем АЦП к Arduino:</p>

<ul>
<li>VCC -&gt; 5V Arduino</li>
<li>DT  -&gt; A2</li>
<li>CLK -&gt; A3</li>
<li>GND -&gt; GND Arduino</li>
</ul>

<p>Клонируем репозиторий</p>

<pre><code>git clone https://github.com/alpha6/HX711_endstop
</code></pre>

<p>и открываем в Arduino IDE скетч - <em>Tenso_sensor.ino</em></p>

<p>В скетче меняем <code>const bool DEBUG = false;</code> на <code>const bool DEBUG = true;</code></p>

<p>Заливаем скетч в Arduino и через Serial monitor смотрим за показаниями.</p>

<p>2 раза в секунду там должна появляться строка</p>

<pre><code>current weight! [848342] [848267]
</code></pre>

<p>цифры будут зависеть от нагрузки на датчик и погоды на Юпитере и могут плавать между измерениями, даже если датчик просто лежит на столе.</p>

<p>Убеждаемся, что значения датчика меняются при воздействии на него. Если меняются, значит, все собрано верно. Если нет - надо поменять местами провода DT и CLK. Я так один раз перепутал контакты DT и CLK: с виду все работало, но при попытке калибровки принтер попытался проломить соплом стол.</p>

<p><strong>В установленном на принтер виде цифра от датчика должна увеличиваться при касании стола!</strong></p>

<p>Теперь сделаем из Arduino концевик для мозгов принтера.</p>

<p>Для управления принтером у меня используется плата Melzi. Для RAMPS все будет сильно проще с точки зрения получения пинов и настройки прошивки.</p>

<p>Для этого нам понадобится любой оптрон и резистор на 1кОм. Оптрон я использовал 4n35, потому что он был под рукой. Любой другой подключается аналогично с разницей на нумерацию ног.</p>

<p>На плате Melzi всего 3 пина под концевики, на Дельте они все используются для калибровки осей. Так что нам нужен какой-то другой концевик. На своем принтере я не использую экран с кнопками, и у меня есть целый свободный разъем на 10 пин рядом с ISP, так что я буду использовать пин A1 оттуда. Для RAMPS никаких подобных телодвижений не надо, благо, концевиков у него хватает.</p>

<ul>
<li>Соединяем землю Arduino и пин 2 оптрона</li>
<li>Сажаем пин 1 через резистор на пин D7</li>
<li>Пин 4 оптрона соединяем с землей 10 пинового разъема на Melzi. Для RAMPS соединяем с землей концевика Z-Min</li>
<li>Пин 5 отпрона соединяем с пином A1 10 пинового разъема на Melzi. Для RAMPS соединяем с сигнальным пином концевика Z-Min.</li>
</ul>

<p>Схема подключения:</p>

<p><img alt="4n35" src="/static/img/hx711/4n35.png"></p>

<p>Устанавливаем датчик на принтер. После того, как все установлено, подводим датчик к столу. Задача - откалибровать порог срабатывания так, чтобы датчик срабатывал от касания стола, но не срабатывал от движений головы.</p>

<p>Для контроля срабатываний без заглядывания в сериал-монитор удобно подключить светодиод. Цепляем землю диода на пин 5 оптрона, а + через резистор на +5В. Теперь диод будет загораться при срабатывании датчика.</p>

<p>Теперь отредактируем прошивку.</p>

<p>Я не буду описывать конфигурацию прошивки с нуля, опишу только специфичные для калибровки вещи. По всему остальному в интернете полно гайдов, а эта статья и так здоровенная выходит.
Предполагается, что все остальное уже настроено для Дельты, принтер работает и нужно только автокалибровку прикрутить.</p>

<p>Будем использовать самые последние решения в стане прошивкостроения.</p>

<p>Клонируем репозиторий Marlin</p>

<pre><code>git clone https://github.com/MarlinFirmware/Marlin.git
</code></pre>

<p>Переключаемся на бранч RcBugFix потому что в master и RC автокалибровка на дельтах не работает.</p>

<pre><code>cd Marlin
git checkout -b RcBugFix
</code></pre>

<p>Открываем прошивку в Arduino IDE. Настраиваем все, что необходимо, и приступаем к настройке автокалибровки.
Первым делом нам надо добавить концевик Z-Min для Melzi. На RAMPS он есть, и этот пункт нужно пропустить.</p>

<p><em>N.B.</em> Если у вас вообще не Дельта с хомингом в Z-MIN, то просто воткните Arduino в Z_MIN и смело пропускайте все настройки высот и прочее, что относится к дельтам или принтерам с хомингом стола в Z_MAX.</p>

<p>Открываем вкладку <code>pins_SANGUINOLOLU_11.h</code> и после</p>

<pre><code>#define E0_DIR_PIN          0
</code></pre>

<p>добавляем строки</p>

<pre><code>#define Z_MIN_PROBE_PIN     30
#define Z_MIN_PIN           30
</code></pre>

<p>Технически, должно хватить только указания Z_MIN_PIN, но в той ревизии, что сейчас лежит в гите, есть баг, и сборка падает, если не задан Z_MIN_PROBE_PIN.</p>

<p>Сохраняем файл и переходим в <code>Configuration.h</code></p>

<p>Раскомментируем строку</p>

<pre><code>#define USE_ZMIN_PLUG
</code></pre>

<p>В строке</p>

<pre><code>#define Z_MIN_PROBE_ENDSTOP_INVERTING false
</code></pre>

<p><code>false</code> меняем на <code>true</code></p>

<p>Раскомментируем строку</p>

<pre><code>#define FIX_MOUNTED_PROBE
</code></pre>

<p>Выставим смещения Z-Probe на 0</p>

<pre><code>#define Y_PROBE_OFFSET_FROM_EXTRUDER 0   // Y offset: -front +behind [the nozzle]
#define Z_PROBE_OFFSET_FROM_EXTRUDER 0
</code></pre>

<p>Раскомментируем строку</p>

<pre><code>#define Z_MIN_PROBE_ENDSTOP
</code></pre>

<p>Ну, и главная наша цель:</p>

<pre><code>#define AUTO_BED_LEVELING_FEATURE
</code></pre>

<p>Тоже раскомментируем. Также раскомментируем строку</p>

<pre><code>#define AUTO_BED_LEVELING_BILINEAR
</code></pre>

<p>Это единственный доступный тип автоуровня для Дельты. Сопло проходит по всему столу и строит квадратную карту высот, по которой потом печатает.
В строке:</p>

<pre><code>#define ABL_GRID_MAX_POINTS_X 3
</code></pre>

<p>регулируется кол-во точек на грани квадрата. Т.е., при настройке в 3 сопло проверит высоту в 9 точках. Если указать 9 - то точек будет 81, время калибровки возрастет соответственно.</p>

<p>Также стоит выставить высоту области печати в значение, близкое к реальному.</p>

<pre><code>#define MANUAL_Z_HOME_POS 156.8
</code></pre>

<p>Сопло после выполнения <code>G28</code> и получения <code>G29</code> идет в минимум со скоростью, указанной для хоминга. Скорость эта по умолчанию составляет 2000 мм/мин, на некотором расстоянии от поверхности стола скорость сбрасывается в 2 раза и на этой скорости происходит касание. Если заданная в прошивке высота области печати будет сильно больше реальной, то сопло просто врежется на полном ходу в стол и датчик может не успеть сработать. Точнее, датчику на срабатывание надо 120мс, за это время сопло пройдет 4мм вниз. А дальше все зависит от прочности конструкции и силы моторов. Один раз таким образом у меня получилось разбить стекло на столе.</p>

<p>А если область печати будет меньше реальной, то от заданной области печати сопло будет идти со скоростью в 2 раза меньше скорости калибровки, и ждать окончания процесса придется очень долго.</p>

<p>Скорости хоминга по Z регулирются этими строками:</p>

<pre><code>#define Z_PROBE_SPEED_FAST HOMING_FEEDRATE_Z
#define Z_PROBE_SPEED_SLOW (Z_PROBE_SPEED_FAST / 2)
</code></pre>

<p>Еще можно включить опцию двойного касания, дает большую точность (в теории), но и занимает больше времени:</p>

<pre><code>#define PROBE_DOUBLE_TOUCH
</code></pre>

<p>Заливаем прошивку в принтер. Проверяем, что работает <code>G28</code>, командой M119 проверяем, что концевик <code>Z-MIN</code> в состоянии <code>open</code>.</p>

<p>Теперь откалибруем датчик веса на нужный уровень срабатывания.</p>

<p>Для этого подводим голову к поверхности стола и прижимаем сопло к столу. В этот момент должен сработать датчик. Если этого не произошло, уменьшаем порог срабатывания:</p>

<pre><code>long trigger = 13000;
</code></pre>

<p>Имеет смысл уменьшать сразу на 1000, но это зависит от используемого датчика. У меня датчик срабатывает от легкого касания сопла пальцем. Чемь меньше будет порог срабатывания, тем лучше, но без фанатизма. Он не должен срабатывать от торможения каретки при калибровке, например.</p>

<p>Датчик работает. В качестве финального штриха к портрету, проверяем, что в разных положения эффектора в области печати не срабатывает датчик из-за натяжения трубки боудена или проводов вентилятора. Пишу этот пункт по собственному опыту, ибо я долго боролся со срабатыванием датчика при торможении каретки, а оказалось, что это трубка боудена дергала хот вверх со всеми вытекающими. После изменения положения мотора экструдера проблема ушла.</p>

<p>Теперь, когда все проверено, говорим G29. Голова поедет вниз и начнет тыкаться в стол согласно количеству точек, указанных в прошивке. После окончания калибровки будет выдана карта высот. Стоит убедиться, что все значения в ней находятся на одном уровне в переделах погрешности (второй цифры после запятой). Ну, это если стол ровный, без бугров, впадин и перекосов.</p>

<p>Все. На этом процесс настройки автокалибровки завершен, и можно заняться ее тюнигом.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2016/09/04/marlin-adding-second-extruder/">Добавляем второй экструдер к RAMPS 1.4/Marlin</a></h1>

        <aside>
            <time datetime="2016-09-04">
                Posted on 2016-09-04
            </time>
            <a data-disqus-identifier="/2016/09/04/marlin-adding-second-extruder/index.markdown" href="/blog/2016/09/04/marlin-adding-second-extruder/#disqus_thread">0 comments</a>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/prusai3/" rel="tag">prusai3</a>
            <a href="/blog/tag/marlin/" rel="tag">marlin</a>
            <a href="/blog/tag/slic3r/" rel="tag">slic3r</a>
        </p>

    </header>

    <p>В <a href="http://alpha6.ru/blog/2016/08/23/marlin-setup/">прошлой серии</a> мы установили прошивку Marin на Arduino Mega+RAMPS 1.4 и откалибровали все это дело. Теперь пришло время добавить второй экструдер.</p>

<p>Для этого нам понадобится:</p>

<ul>
<li>второй экструдер</li>
<li>второй хот-энд в сборе и все прилегающие детали, типа трубки боудена</li>
<li>каретка на два экструдера. Я использую <a href="http://www.thingiverse.com/thing:1749633">такую</a>.</li>
</ul>

<p>В общем случае все просто идем в Arduino IDE и правим конфигурацию.</p>

<p>Меняем конфигурацию платы управления на RAMPS 1.4 c 2 экструдерами и подогреваемым столом</p>

<pre><code>#ifndef MOTHERBOARD
  #define MOTHERBOARD BOARD_RAMPS_14_EEB
#endif
</code></pre>

<p>Указываем кол-во экструдеров:</p>

<pre><code>#define EXTRUDERS 2
</code></pre>

<p>Указываем тип датчика температуры для второго экструдера:</p>

<pre><code>#define TEMP_SENSOR_1 1
</code></pre>

<p>Максимальную температуру:</p>

<pre><code>#define HEATER_1_MAXTEMP 250
</code></pre>

<p>Если надо, устанавливаем направление вращения мотора:</p>

<pre><code>#define INVERT_E1_DIR true
</code></pre>

<p>В целом, если у вас одинаковые моторы на обоих экструдерах, то на этом настройка закончена.</p>

<p>Но если у моторы разные или  на одном экструдере у меня мотор с шестерней подачи диаметром 10мм, а на втором - 7мм, то тут начинаются проблемы с калибровкой.</p>

<p>Как откалибровать второй экструдер?
Идем в пронтерфейс и говорим:</p>

<pre><code>T1
</code></pre>

<p>Эта команда указывает что сейчас активен экструдер номер 2 (отсчет начинается с 0). Включаем подачу филамента, для подачи будет использоваться число шагов из прошивки, т.е. для первого экструдера. Смотрим разницу и с помощью пропорции получаем кол-во шагов для активного экструдера. У меня из-за разницы в подающих шестернях получилось 80 шагов на мм.</p>

<p>Говорим:</p>

<pre><code>M92 E80
</code></pre>

<p>Этим мы устанавливаем новое кол-во шагов для текущего экструдера. Проверяем, при необходимости подгоняем значение.</p>

<p>После калибровки вылезает проблема - Marlin не поддерживает установку разного числа шагов для разных экструдеров, соответственно в прошивке нам эти данные не сохранить. Придется этот вопрос решать програмно.</p>

<p>Напишем небольшой фильтр которым будем обрабатывать готовый g-code файл.</p>

<pre><code>#!/usr/bin/env perl

use strict;

my $T0 = &#39;M92 E95&#39;;
my $T1 = &#39;M92 E80&#39;;

local $^I = &#39;.bak&#39;;
while (&lt;&gt;) {
    s/^T0/T0\n$T0/;
    s/^T1/T1\n$T1/;
    print;
}
</code></pre>

<p>Этот скрипт ищет команду T<num> и заменяет ее нужным нам значением. В данном случае добавляет команду M92 E<steps>.
Скрипт получает на вход имя файла, перебирает его построчно и в каждой строке заменяет совпадения на то что мы указали. Оригинальный файл сохраняется с расширением <code>.bak</code>.</steps></num></p>

<p>Дальше нам надо задать смещение экструдеров</p>

<p>Для Slic3r идем в <code>Printer Settings</code> -&gt; <code>Extruder 2</code> и выставляем смещение. Примерное смещение можно получить если измерив расстояние между соплами, однако программое расстояние может отличаться от физического расстояния, так что все равно придется заняться калибровкой.</p>

<p>Для этого печатаем деталь для <a href="http://www.thingiverse.com/thing:124450">калибровки 2х экструдеров</a> и точно подгоняем все для идеальной работы.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2016/08/23/marlin-setup/">Настраиваем прошивку Marlin для Arduino + RAMPS 1.4</a></h1>

        <aside>
            <time datetime="2016-08-23">
                Posted on 2016-08-23
            </time>
            <a data-disqus-identifier="/2016/08/23/marlin-setup/index.markdown" href="/blog/2016/08/23/marlin-setup/#disqus_thread">0 comments</a>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/prusai3/" rel="tag">prusai3</a>
            <a href="/blog/tag/3dprinting/" rel="tag">3dprinting</a>
            <a href="/blog/tag/ramps/" rel="tag">ramps</a>
            <a href="/blog/tag/marlin/" rel="tag">marlin</a>
        </p>

    </header>

    <p>Так получилось что некоторое время назад я стал владельцем китайского клона Prusa i3 под гордым китайским названием Hesine M505.
Это чудо китайской мысли конечно было далеко от совершенства, но с задачей печатать все подряд справлялось вполне успешно. Однако, чем дальше в лес - тем толще партизаны. И забравшись в лес подальше возжелал я печатать детали с использованием растворимых поддержек, да и двумя цветами печатать тоже было бы  неплохо.</p>

<p>К сожалению, у родной для принтера платы Melzi V2 был фатальный недостаток - на ней отсутсвовал порт для подключения второго экструдера. Изучение матчасти показало, что можно взять еще одну такую же плату и воткнуть ее в режиме слейва. Однако ценник на это удовольствие получался высоковатым. И, что самое неприятно, при таком апгрейде терялась возможность подключения экрана и кнопок управления. Т.е. печатать можно будет только с компьютера, а это не самая лучшая идея по многим причинам.</p>

<p>Так я пришел к решению полностью заменить мозги принтера. Выбор был сделан в пользу нестареющей класски Arduino Mega 2560 + RAMPS 1.4 + A4988. Быстро сказка сказывается, да долго посылочка едет. Получив посылку с мозгами, моторами и прочим полезным в хозяйстве инвентарем я обнаружил что забыл заказать шестерню податчика экструдера. Благо на тот момент она уже ехала ко мне с али, где я заказал ее просто так, от жадности.</p>

<p>В общем, пока необходимые запчасти едут, можно подключить и отстроить новые мозги в конфигурации с одним экструдером, а потом просто переконфигурировать прошивку когда будет собрано все железо.</p>

<p>Ставить мы будем классику жанра - Marlin. Клонируем репозиторий в любое удобное место отсюда https://github.com/MarlinFirmware/Marlin. Скачиваем Arduino IDE.</p>

<p>В Arduino IDE открываем прошивку.
Выбираем нашу плату Arduino Mega 2560 и процессор AtMega 2560.</p>

<p>Дальше нас интересует вкладка с файлом Configuration.h, теперь мы будем его безудержно править.</p>

<p>Выбираем нашу плату: RAMPS 1.4 с одним хотэндом</p>

<pre><code>#ifndef MOTHERBOARD
  #define MOTHERBOARD BOARD_RAMPS_14_EFB
#endif
</code></pre>

<p>В файле boards.h приведен полный список поддерживаемых плат и их вариаций. Нас пока интересует только RAMPS 1.4 с одним экструдером.</p>

<p>Выставляем кол-во температурных сенсоров. Сенсоров должно быть по числу экструдеров. В нашем случае 1. Убеждаемся что напротив первого сенсора в списке стоит 1.</p>

<pre><code>#define TEMP_SENSOR_0 1
</code></pre>

<p>Выставляем максимальную температуру хотэнда и стола.</p>

<pre><code>#define HEATER_0_MAXTEMP 250
#define BED_MAXTEMP 130
</code></pre>

<p>У меня стоят термопредохранители на 252 градуса, так что максимальная температура хота должна быть ниже температуры срабатывания предохранителя. Если собираетесь печатать чем-то вроде поликарбоната - то температуру надо поднять. Со столом таже история, единственное что даже печать нейлоном не требует очень больших температур стола, 130 градусов должно хватить всем.</p>

<p>В Hesine M505 стоят нормально замкнутые концевики, а в прошивка по умолчанию рассчитывает на нормально разомкнутые.
Включаем инвертирование концевиков:</p>

<pre><code>// Mechanical endstop with COM to ground and NC to Signal uses &quot;false&quot; here (most common setup).
#define X_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
#define Y_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
#define Z_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
</code></pre>

<p>Проверяем направление вращения моторов. Тут история примерно таже что и с концевиками, т.к. прошивка изначально рассчитана на Ultimaker.</p>

<pre><code>// Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
#define INVERT_X_DIR true
#define INVERT_Y_DIR true
#define INVERT_Z_DIR false
</code></pre>

<p>И для экструдера повторяем операцию.</p>

<pre><code>#define INVERT_E0_DIR true
</code></pre>

<p>Выставляем размеры рабочей зоны</p>

<pre><code>#define X_MIN_POS 0
#define Y_MIN_POS 0
#define Z_MIN_POS 0
#define X_MAX_POS 250
#define Y_MAX_POS 230
#define Z_MAX_POS 140
</code></pre>

<p>Для начала можно выставить заводомо большие чем рабочая зона габариты. Потом все откалибруется по месту. По умолчанию в прошивке стоят значени 200х200х200, тогда как у Hesine M505 рабочее поле по всем направлениям больше чем эти цифры. И прошивка просто не даст двигаться за их пределы.</p>

<p>Устанавливаем координаты начала стола. Это нужно чтобы ноль стола в слайсере совпадал с нулем в координатах принтера. Иначе модель может вылезать за пределы зоны печати.</p>

<pre><code>#define MANUAL_X_HOME_POS -30
#define MANUAL_Y_HOME_POS -20
</code></pre>

<p>Выставляем шаги для моторов.</p>

<pre><code>#define DEFAULT_AXIS_STEPS_PER_UNIT   {100,100,1600,95}
</code></pre>

<p>Параметры тут следующие: мотор_Х, мотор_Y, мотор_Z, мотор_экструдера</p>

<p>Для рассчета шагов по X и Y используем следующую формулу:</p>

<pre><code>(200*16)/(16*2)=80 шагов
</code></pre>

<p>Где 200 - это число шагов двигателя на 360 градусов. Типичная цифра для моторов с шагом 1.8 градуса.
16 в числителе - кол-во микрошагов на шаг.
16 в знаменателе - кол-во зубов на шпуле.
2 - стандартный шаг для ремня GT2</p>

<p>Для Z:</p>

<pre><code>3200/2 = 1600
</code></pre>

<p>В Hesine M505 штатно используется трапециидальный винт с шагом резьбы 2мм. Соответственно мы белим число шагов на полный оборот на кол-во миллиметров которые будут пройдены за оборот и получаем число шагов на миллиметр.</p>

<p>Подачу экструдера пока посчитаем и выставим предварительно. Потом ее все равно придется подгонять.
Шестерня экструдера штатно имеет диаметр около 10мм. Получаем длинну окружности на один оборот: 3.14*10=31.4 мм на оборот.</p>

<p>Делим число шагов на длинну окружности и получаем число шагов на миллиметр.</p>

<pre><code>3200/31.4=101.9
</code></pre>

<p>округляем до 102.</p>

<p>Заливаем все это дело в Arduino.</p>

<p>После того как все залилось и все железо подключено запускаем Pronterface и начинаем калибровку.</p>

<ul>
<li>Двигаем моторы и проверяем что они крутятся в нужную сторону. Если это не так - меняем параметр INVERT_*_DIR на противоположное значение.</li>
<li>Проверяем состояние концевиков. По команде M119 будет показано состояние концевиков. Если концевик нажат - напротив него должно быть написано TRIGGERED. Напротив ненажатого - open. Если это не так - меняем настройку *<em>MIN</em>ENDSTOP_INVERTING.</li>
<li>Даем команду G28. Все оси должны приехать в свое минимальное положение. Дальше через Pronterface двигаем все оси в их безопасное максимальное положение и даем комаду M114. Она покажет текущее положение по осям. Вносим эти данные в настройку *<em>MAX</em>POS.</li>
<li>Опять говорим G28. Передвигаем экструдер в нулевую координату стола по X-Y. Смотрим что показывает M114 и эти цифры переносим в MANUAL_*<em>HOME</em>POS с обратным знаком. Т.е. если M114 говорит что координата по Х сейчас 30 - то в настройку пишем -30. Это значит что после ухода в HOME экструдер отъедет от него на 30мм и будет считать это положение нолем.</li>
<li>откручиваем сопло или трубку боудена у экструдера. На прутке отмечаем расстояние, например 10 см, и прогоняем эту же длинну из Pronterface. После этого смотрим сколько в реальности прошло прутка и корректируем кол-во шагов для экструдера чтобы он прогонял четко нужное кол-во пластика. Важно понимать что на горячую с установленным соплом эта цифра все равно будет отличаться от установленного. Если вы всегда печатаете соплом одного диаметра - можно повторить эту операцию с соплом и полученные данные внести в прошивку. Я использую несколько сопел, так что объем пластика корректирую через настройку потока в слайсере.</li>
</ul>

<p>После того как все это сделано - печатаем тестовую модель. Я использую пустой куб 20х20х20 мм. После того как он отпечатан - проверяем что размеры сторон у нас точно соответсвуют тому что должно быть. Если это не так по отдельным измерениям - корректируем кол-во шагов для нужной оси.</p>

<p>На этом основные настройки закончены. Дальше можно тюнить приведенные выше параметры для более качественной печати.</p>



</article>

<ul class="pager">
    <li class="prev">
            <button disabled>
                ← Older
            </button>
    </li>
    <li class="next">
            <button disabled>
                Newer →
            </button>
    </li>
</ul>

<script type="text/javascript">
    var disqus_shortname = 'alpha6sblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>



                    </main>
                </div>

                <div class="three columns sidebar">
                    
                        <nav id="tags">
        <h1>Tags</h1>
        <ul class="list-inline">
            <li><a href="/blog/tag/3d-printer/">3d-printer</a></li>
            <li><a href="/blog/tag/3dprinting/">3dprinting</a></li>
            <li><a href="/blog/tag/airplay/">airplay</a></li>
            <li><a href="/blog/tag/anyevent/">AnyEvent</a></li>
            <li><a href="/blog/tag/apache-http/">apache.http</a></li>
            <li><a href="/blog/tag/armbian/">armbian</a></li>
            <li><a href="/blog/tag/autolevel/">autolevel</a></li>
            <li><a href="/blog/tag/automation/">automation</a></li>
            <li><a href="/blog/tag/bugs/">bugs</a></li>
            <li><a href="/blog/tag/confluence/">confluence</a></li>
            <li><a href="/blog/tag/convos/">convos</a></li>
            <li><a href="/blog/tag/data/">data</a></li>
            <li><a href="/blog/tag/dbd-pg/">dbd::pg</a></li>
            <li><a href="/blog/tag/debian/">debian</a></li>
            <li><a href="/blog/tag/diy/">diy</a></li>
            <li><a href="/blog/tag/elasticsearch/">elasticsearch</a></li>
            <li><a href="/blog/tag/elcapitan/">elcapitan</a></li>
            <li><a href="/blog/tag/email/">email</a></li>
            <li><a href="/blog/tag/gearman/">gearman</a></li>
            <li><a href="/blog/tag/git/">git</a></li>
            <li><a href="/blog/tag/graylog/">graylog</a></li>
            <li><a href="/blog/tag/graylog2/">graylog2</a></li>
            <li><a href="/blog/tag/hardware/">hardware</a></li>
            <li><a href="/blog/tag/io/">io</a></li>
            <li><a href="/blog/tag/irc/">irc</a></li>
            <li><a href="/blog/tag/java/">java</a></li>
            <li><a href="/blog/tag/jcifs/">jcifs</a></li>
            <li><a href="/blog/tag/json/">json</a></li>
            <li><a href="/blog/tag/kodi/">kodi</a></li>
            <li><a href="/blog/tag/lc_all/">lc_all</a></li>
            <li><a href="/blog/tag/linux/">linux</a></li>
            <li><a href="/blog/tag/macos/">macos</a></li>
            <li><a href="/blog/tag/marlin/">marlin</a></li>
            <li><a href="/blog/tag/melzi/">melzi</a></li>
            <li><a href="/blog/tag/net-smtp/">net::smtp</a></li>
            <li><a href="/blog/tag/nginx/">nginx</a></li>
            <li><a href="/blog/tag/note/">note</a></li>
            <li><a href="/blog/tag/orange-pi/">orange pi</a></li>
            <li><a href="/blog/tag/orangepi/">orangepi</a></li>
            <li><a href="/blog/tag/package/">package</a></li>
            <li><a href="/blog/tag/perl/">perl</a></li>
            <li><a href="/blog/tag/postgresql/">postgresql</a></li>
            <li><a href="/blog/tag/power/">power</a></li>
            <li><a href="/blog/tag/prusai3/">prusai3</a></li>
            <li><a href="/blog/tag/ramps/">ramps</a></li>
            <li><a href="/blog/tag/redmine/">redmine</a></li>
            <li><a href="/blog/tag/rex/">rex</a></li>
            <li><a href="/blog/tag/rostock/">rostock</a></li>
            <li><a href="/blog/tag/samba/">samba</a></li>
            <li><a href="/blog/tag/serial-port/">serial port</a></li>
            <li><a href="/blog/tag/shairport/">shairport</a></li>
            <li><a href="/blog/tag/slic3r/">slic3r</a></li>
            <li><a href="/blog/tag/snippet/">snippet</a></li>
            <li><a href="/blog/tag/spotlight/">spotlight</a></li>
            <li><a href="/blog/tag/state/">state</a></li>
            <li><a href="/blog/tag/timestamp/">timestamp</a></li>
            <li><a href="/blog/tag/trap/">trap</a></li>
            <li><a href="/blog/tag/ubuntu/">ubuntu</a></li>
            <li><a href="/blog/tag/weight-sensor/">weight sensor</a></li>
            <li><a href="/blog/tag/windows/">windows</a></li>
        </ul>
    </nav>

                            <h1>Feeds</h1>
        <ul class="list-inline">
            <li>
                <a href="/blog/tag/marlin.atom" rel="alternate" type="application/atom+xml">
                    Atom
                </a>
            </li>
            <li>
                <a href="/blog/tag/marlin.rss" rel="alternate" type="application/rss+xml">
                    RSS
                </a>
            </li>
        </ul>

                </div>
            </div>
        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>

        <!-- Yandex.Metrika informer --> <a href="https://metrika.yandex.ru/stat/?id=7948447&amp;from=informer" rel="nofollow" target="_blank"><img alt="Яндекс.Метрика" class="ym-advanced-informer" data-cid="7948447" data-lang="ru" src="https://informer.yandex.ru/informer/7948447/3_1_FFFFFFFF_EFEFEFFF_0_pageviews" style="width:88px; height:31px; border:0;" title="Яндекс.Метрика: данные за сегодня (просмотры, визиты и уникальные посетители)"></a> <!-- /Yandex.Metrika informer --> <!-- Yandex.Metrika counter --> <script type="text/javascript"> (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter7948447 = new Ya.Metrika({ id:7948447, clickmap:true, trackLinks:true, accurateTrackBounce:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img alt="" src="https://mc.yandex.ru/watch/7948447" style="position:absolute; left:-9999px;"></div></noscript> <!-- /Yandex.Metrika counter -->


    </body>
</html>
