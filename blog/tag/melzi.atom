<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alpha6.ru/blog/tag/melzi/</id>
    <title>Just another blog</title>
    <updated>2017-02-09T00:00:00Z</updated>
    <link href="http://alpha6.ru/blog/tag/melzi.atom" rel="self" />
    <link href="http://alpha6.ru/blog/tag/melzi/" rel="alternate" />
    <generator version="0.093">Statocles</generator>

    <entry>
        <id>http://alpha6.ru/blog/2017/02/09/rostock-autolevel/</id>
        <title>Автоматическая калибровка на датчике веса на примере Rostock mini</title>
        <link href="http://alpha6.ru/blog/2017/02/09/rostock-autolevel/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Во всех моих 3д-принтерах меня каждый раз неимоверно бесила необходимость выставлять высоту сопла над уровнем стола. Необходимость эта возникала регулярно, при каждой замене сопла или каких-то других действиях с хотэндом, требовавших его разборки.</p>

<p>Периодически я видел всякие конструкции на базе датчиков приближения (холла), оптических датчиков и прочих шайтан-машин. Но все они требовали точно так же выставлять уровень сопла после каких-либо манипуляций с хотом. Правда, теперь уровень задавался относительно датчика, а не стола. Но радости это все равно не приносило.</p>

<p>Проблему решать надо было кардинально. Для этого нужно, чтобы в качестве датчика уровня использовалось само сопло.</p>

<p>Первое и самое очевидное решение - кинуть один провод на хот, второй на стол, и все это дело завсести на пины концевика. Надежное и дешевое решение, если у вас стол из алюминия без покрытия. У меня на столе лежит зеркало, и такой способ мне не подходит.</p>

<p>Второй способ был - поставить микрик на каретку так, чтобы касание соплом стола вызывало срабатывание микрика. Способ рабочий, но у меня не получилось избавиться от люфтов в креплении хот-энда, и я от него отказался.</p>

<p>Затем на просторах ютуба я увидел, как работает автоматическая калибровка на датчике веса. Правда, там пленочные датчики крепились на стол, но быстрый поиск по запасникам алиэкспресса выдал металлические датчики в виде брусков, на которые уже можно повесить хот-энд.</p>

<p>Я заказал <a href="http://alipromo.com/redirect/cpa/o/ol4k5ubfoept22yoak4cceyn43ykeuok/">модуль АЦП HX711</a> и сам <a href="http://alipromo.com/redirect/cpa/o/ol4k7ueyxqvue32fhvhmfy8n830yd08f/">датчик на 1кг</a>. Спустя месяц ожидания все это дело было получено и настало время прикрутить эту красоту к принтеру.</p>

<p>Есть два варианта подключения. Первый - это подключить АЦП напрямую к мозгам принтера и сказать прошивке, что это датчик веса. Но это решение, на мой взгляд, сильно так себе. Во-первых, поддержка таких датчиков находится пока только в экспериментальном состоянии. Во-вторых, мозгам и так есть чем заняться помимо того, чтобы постоянно читать вес от датчика и пытаться понять, что там происходит.
Значит нам нужен второй вариант: подключить это через промежуточный контроллер, который будет прикидываться концевиком для мозгов принтера. Его и выберем.</p>

<p>План действий будет следующий:</p>

<ul>
<li>Печатаем крепления датчика на эффектор</li>
<li>Подключаем датчик веса к Arduino</li>
<li>Подключаем Arduino с датчиком к мозгам принтера</li>
<li>Редактируем прошивку принтера.</li>
</ul>

<p>Крепления можно скачать <a href="http://www.thingiverse.com/thing:2102961">тут</a>. Вариант сыроватый, но рабочий и дорабатываемый по мере выявления недостатков.</p>

<p>Теперь подключаем контроллер к АЦП. Я нарыл в закромах Arduino Nano, но это не принципиально. На время отладки и калибровки сойдет и так, а дальше я поменяю на Attiny13, которая будет монтироваться вместе с платой АЦП прямо на эффектор для уменьшения уровня наводок по всем этим трактам. Почему на эффектор, а не рядом с основными мозгами принтера? Потому что для наилучшей точности стоит максимально укоротить провода между АЦП и датчиком веса. А если мы монтируем туда АЦП, то есть смысл прицепить туда и контроллер, чтобы от эффектора просто вести три провода к мозгам.</p>

<p>Также с этим АЦП есть нюанс: по умолчанию частота выборок АЦП составляет 10Гц, что слишком мало для нашего применения. То есть, технически, будет работать и так, но точность срабатывания будет плохой.
Для нормальной работы надо перевести АЦП в режим частоты опроса 80Гц. Для этого надо отцепить ногу <code>RATE</code> от земли и посадить ее на VCC.
<img alt="HX711 schema" src="http://alpha6.ru/static/img/hx711/HX711-schema.jpg"></p>

<p>Тут есть два варианта, зависят от ревизии платы HX711.</p>

<p>Вариант с новой ревизией - просто отпаиваем резистор под которым написано 10Hz и запаиваем перемычку в красном квадрате (слева от которой написано 80Hz).
<img alt="HX711 new" src="http://alpha6.ru/static/img/hx711/HX711-2.jpg"></p>

<p>Если не повезло и пришла старая ревизия, то надо отпаять от платы вторую сверху ногу со стороны 4х-пинового разъема и подпаять ее к VCC или первой сверху ноге.
 <img alt="HX711 old" src="http://alpha6.ru/static/img/hx711/HX711-1.jpg"></p>

<p>Все, модуль переключен в режим опроса 80Гц и наша жизнь стала немного прекраснее.</p>

<p>Зачем это проделывать? Так как показания датчика нестабильны из-за наличия вентилятора на голове и постоянных движений эффектора в процессе калибровки, то в скетче используется фильтр НЧ, который сглаживает скачки показаний датчика для большей надежности работы. Фильтр берет 10 значений веса и из них получает отфильтрованные показания. На частоте 80Гц выборка 10 значений занимает примерно 120мс, на частоте 10Гц - займет секунду. Соответственно, надо жертвовать фильтром, что будет приводить к ложным срабатываниям во время движения головы.</p>

<p>Подключаем датчик к АЦП. Соединяем провода:</p>

<ul>
<li>Красный -&gt; E+</li>
<li>Черный  -&gt; E-</li>
<li>Белый   -&gt; A-</li>
<li>Зеленый -&gt; A+</li>
</ul>

<p>Подключаем АЦП к Arduino:</p>

<ul>
<li>VCC -&gt; 5V Arduino</li>
<li>DT  -&gt; A2</li>
<li>CLK -&gt; A3</li>
<li>GND -&gt; GND Arduino</li>
</ul>

<p>Клонируем репозиторий</p>

<pre><code>git clone https://github.com/alpha6/HX711_endstop
</code></pre>

<p>и открываем в Arduino IDE скетч - <em>Tenso_sensor.ino</em></p>

<p>В скетче меняем <code>const bool DEBUG = false;</code> на <code>const bool DEBUG = true;</code></p>

<p>Заливаем скетч в Arduino и через Serial monitor смотрим за показаниями.</p>

<p>2 раза в секунду там должна появляться строка</p>

<pre><code>current weight! [848342] [848267]
</code></pre>

<p>цифры будут зависеть от нагрузки на датчик и погоды на Юпитере и могут плавать между измерениями, даже если датчик просто лежит на столе.</p>

<p>Убеждаемся, что значения датчика меняются при воздействии на него. Если меняются, значит, все собрано верно. Если нет - надо поменять местами провода DT и CLK. Я так один раз перепутал контакты DT и CLK: с виду все работало, но при попытке калибровки принтер попытался проломить соплом стол.</p>

<p><strong>В установленном на принтер виде цифра от датчика должна увеличиваться при касании стола!</strong></p>

<p>Теперь сделаем из Arduino концевик для мозгов принтера.</p>

<p>Для управления принтером у меня используется плата Melzi. Для RAMPS все будет сильно проще с точки зрения получения пинов и настройки прошивки.</p>

<p>Для этого нам понадобится любой оптрон и резистор на 1кОм. Оптрон я использовал 4n35, потому что он был под рукой. Любой другой подключается аналогично с разницей на нумерацию ног.</p>

<p>На плате Melzi всего 3 пина под концевики, на Дельте они все используются для калибровки осей. Так что нам нужен какой-то другой концевик. На своем принтере я не использую экран с кнопками, и у меня есть целый свободный разъем на 10 пин рядом с ISP, так что я буду использовать пин A1 оттуда. Для RAMPS никаких подобных телодвижений не надо, благо, концевиков у него хватает.</p>

<ul>
<li>Соединяем землю Arduino и пин 2 оптрона</li>
<li>Сажаем пин 1 через резистор на пин D7</li>
<li>Пин 4 оптрона соединяем с землей 10 пинового разъема на Melzi. Для RAMPS соединяем с землей концевика Z-Min</li>
<li>Пин 5 отпрона соединяем с пином A1 10 пинового разъема на Melzi. Для RAMPS соединяем с сигнальным пином концевика Z-Min.</li>
</ul>

<p>Схема подключения:</p>

<p><img alt="4n35" src="http://alpha6.ru/static/img/hx711/4n35.png"></p>

<p>Устанавливаем датчик на принтер. После того, как все установлено, подводим датчик к столу. Задача - откалибровать порог срабатывания так, чтобы датчик срабатывал от касания стола, но не срабатывал от движений головы.</p>

<p>Для контроля срабатываний без заглядывания в сериал-монитор удобно подключить светодиод. Цепляем землю диода на пин 5 оптрона, а + через резистор на +5В. Теперь диод будет загораться при срабатывании датчика.</p>

<p>Теперь отредактируем прошивку.</p>

<p>Я не буду описывать конфигурацию прошивки с нуля, опишу только специфичные для калибровки вещи. По всему остальному в интернете полно гайдов, а эта статья и так здоровенная выходит.
Предполагается, что все остальное уже настроено для Дельты, принтер работает и нужно только автокалибровку прикрутить.</p>

<p>Будем использовать самые последние решения в стане прошивкостроения.</p>

<p>Клонируем репозиторий Marlin</p>

<pre><code>git clone https://github.com/MarlinFirmware/Marlin.git
</code></pre>

<p>Переключаемся на бранч RcBugFix потому что в master и RC автокалибровка на дельтах не работает.</p>

<pre><code>cd Marlin
git checkout -b RcBugFix
</code></pre>

<p>Открываем прошивку в Arduino IDE. Настраиваем все, что необходимо, и приступаем к настройке автокалибровки.
Первым делом нам надо добавить концевик Z-Min для Melzi. На RAMPS он есть, и этот пункт нужно пропустить.</p>

<p><em>N.B.</em> Если у вас вообще не Дельта с хомингом в Z-MIN, то просто воткните Arduino в Z_MIN и смело пропускайте все настройки высот и прочее, что относится к дельтам или принтерам с хомингом стола в Z_MAX.</p>

<p>Открываем вкладку <code>pins_SANGUINOLOLU_11.h</code> и после</p>

<pre><code>#define E0_DIR_PIN          0
</code></pre>

<p>добавляем строки</p>

<pre><code>#define Z_MIN_PROBE_PIN     30
#define Z_MIN_PIN           30
</code></pre>

<p>Технически, должно хватить только указания Z_MIN_PIN, но в той ревизии, что сейчас лежит в гите, есть баг, и сборка падает, если не задан Z_MIN_PROBE_PIN.</p>

<p>Сохраняем файл и переходим в <code>Configuration.h</code></p>

<p>Раскомментируем строку</p>

<pre><code>#define USE_ZMIN_PLUG
</code></pre>

<p>В строке</p>

<pre><code>#define Z_MIN_PROBE_ENDSTOP_INVERTING false
</code></pre>

<p><code>false</code> меняем на <code>true</code></p>

<p>Раскомментируем строку</p>

<pre><code>#define FIX_MOUNTED_PROBE
</code></pre>

<p>Выставим смещения Z-Probe на 0</p>

<pre><code>#define Y_PROBE_OFFSET_FROM_EXTRUDER 0   // Y offset: -front +behind [the nozzle]
#define Z_PROBE_OFFSET_FROM_EXTRUDER 0
</code></pre>

<p>Раскомментируем строку</p>

<pre><code>#define Z_MIN_PROBE_ENDSTOP
</code></pre>

<p>Ну, и главная наша цель:</p>

<pre><code>#define AUTO_BED_LEVELING_FEATURE
</code></pre>

<p>Тоже раскомментируем. Также раскомментируем строку</p>

<pre><code>#define AUTO_BED_LEVELING_BILINEAR
</code></pre>

<p>Это единственный доступный тип автоуровня для Дельты. Сопло проходит по всему столу и строит квадратную карту высот, по которой потом печатает.
В строке:</p>

<pre><code>#define ABL_GRID_MAX_POINTS_X 3
</code></pre>

<p>регулируется кол-во точек на грани квадрата. Т.е., при настройке в 3 сопло проверит высоту в 9 точках. Если указать 9 - то точек будет 81, время калибровки возрастет соответственно.</p>

<p>Также стоит выставить высоту области печати в значение, близкое к реальному.</p>

<pre><code>#define MANUAL_Z_HOME_POS 156.8
</code></pre>

<p>Сопло после выполнения <code>G28</code> и получения <code>G29</code> идет в минимум со скоростью, указанной для хоминга. Скорость эта по умолчанию составляет 2000 мм/мин, на некотором расстоянии от поверхности стола скорость сбрасывается в 2 раза и на этой скорости происходит касание. Если заданная в прошивке высота области печати будет сильно больше реальной, то сопло просто врежется на полном ходу в стол и датчик может не успеть сработать. Точнее, датчику на срабатывание надо 120мс, за это время сопло пройдет 4мм вниз. А дальше все зависит от прочности конструкции и силы моторов. Один раз таким образом у меня получилось разбить стекло на столе.</p>

<p>А если область печати будет меньше реальной, то от заданной области печати сопло будет идти со скоростью в 2 раза меньше скорости калибровки, и ждать окончания процесса придется очень долго.</p>

<p>Скорости хоминга по Z регулирются этими строками:</p>

<pre><code>#define Z_PROBE_SPEED_FAST HOMING_FEEDRATE_Z
#define Z_PROBE_SPEED_SLOW (Z_PROBE_SPEED_FAST / 2)
</code></pre>

<p>Еще можно включить опцию двойного касания, дает большую точность (в теории), но и занимает больше времени:</p>

<pre><code>#define PROBE_DOUBLE_TOUCH
</code></pre>

<p>Заливаем прошивку в принтер. Проверяем, что работает <code>G28</code>, командой M119 проверяем, что концевик <code>Z-MIN</code> в состоянии <code>open</code>.</p>

<p>Теперь откалибруем датчик веса на нужный уровень срабатывания.</p>

<p>Для этого подводим голову к поверхности стола и прижимаем сопло к столу. В этот момент должен сработать датчик. Если этого не произошло, уменьшаем порог срабатывания:</p>

<pre><code>long trigger = 13000;
</code></pre>

<p>Имеет смысл уменьшать сразу на 1000, но это зависит от используемого датчика. У меня датчик срабатывает от легкого касания сопла пальцем. Чемь меньше будет порог срабатывания, тем лучше, но без фанатизма. Он не должен срабатывать от торможения каретки при калибровке, например.</p>

<p>Датчик работает. В качестве финального штриха к портрету, проверяем, что в разных положения эффектора в области печати не срабатывает датчик из-за натяжения трубки боудена или проводов вентилятора. Пишу этот пункт по собственному опыту, ибо я долго боролся со срабатыванием датчика при торможении каретки, а оказалось, что это трубка боудена дергала хот вверх со всеми вытекающими. После изменения положения мотора экструдера проблема ушла.</p>

<p>Теперь, когда все проверено, говорим G29. Голова поедет вниз и начнет тыкаться в стол согласно количеству точек, указанных в прошивке. После окончания калибровки будет выдана карта высот. Стоит убедиться, что все значения в ней находятся на одном уровне в переделах погрешности (второй цифры после запятой). Ну, это если стол ровный, без бугров, впадин и перекосов.</p>

<p>Все. На этом процесс настройки автокалибровки завершен, и можно заняться ее тюнигом.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/3d-printer/">3d-printer</a>
                    <a href="http://alpha6.ru/blog/tag/melzi/">melzi</a>
                    <a href="http://alpha6.ru/blog/tag/marlin/">marlin</a>
                    <a href="http://alpha6.ru/blog/tag/rostock/">rostock</a>
                    <a href="http://alpha6.ru/blog/tag/autolevel/">autolevel</a>
                    <a href="http://alpha6.ru/blog/tag/weight-sensor/">weight sensor</a>
                </p>

        ]]></content>
        <updated>2017-02-09T00:00:00Z</updated>
        <category term="3d-printer" />
        <category term="melzi" />
        <category term="marlin" />
        <category term="rostock" />
        <category term="autolevel" />
        <category term="weight sensor" />
    </entry>
</feed>

