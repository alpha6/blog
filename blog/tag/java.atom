<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alpha6.ru/blog/tag/java/</id>
    <title>Just another blog</title>
    <updated>2016-11-27T10:44:37Z</updated>
    <link href="http://alpha6.ru/blog/tag/java.atom" rel="self" />
    <link href="http://alpha6.ru/blog/tag/java/" rel="alternate" />
    <generator version="0.077">Statocles</generator>
    <entry>
        <id>http://alpha6.ru/blog/2016/10/18/httpresponse-json/</id>
        <title>Корректное получение JSON ответа через Apache.HttpClient</title>
        <link href="http://alpha6.ru/blog/2016/10/18/httpresponse-json/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>У Apache HttpClient есть небольшая, но неприятная бага. Всплыла она при работе с REST API Confluence (вообще очень много баг всплывает при работе с API  продуктов Atlassian, но это все лирика).</p>

<p>В чем, собственно, проблема? Проблема в том, что Confluence при запросе у него данных с Accept: application/json (собственно все JSON REST API) не выставляет заголовок content-encoding для отдаваемых данных. В целом, его можно понять т.к. по стандарту JSON всегда должен быть UTF-8, но HttpClient не понимает и потому разбирает входящие данные как ISO.</p>

<p>Соответственно, дальше JSONObject при парсинге Entity превращает русский текст в совершенно непотребное.</p>

<p>Лечится это элементарно, просто при работае с Entity принудительно указываем ей что кодировка у нас UTF-8.</p>

<p>Вот так:</p>

<pre><code>JSONObject jsonObj = new JSONObject(EntityUtils.toString(response.getEntity, &quot;UTF-8&quot;));
</code></pre>

                <p><a href="http://alpha6.ru/blog/2016/10/18/httpresponse-json/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://alpha6.ru/blog/tag/java/">java</a>
                <a href="http://alpha6.ru/blog/tag/json/">json</a>
                <a href="http://alpha6.ru/blog/tag/apache-http/">apache.http</a>
                <a href="http://alpha6.ru/blog/tag/confluence/">confluence</a>
            </p>
        ]]></content>
        <updated>2016-10-18T00:00:00Z</updated>
        <category term="java" />
        <category term="json" />
        <category term="apache.http" />
        <category term="confluence" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/08/07/java-jcifs/</id>
        <title>Работаем с самбой из Java с помощью JCIFS</title>
        <link href="http://alpha6.ru/blog/2016/08/07/java-jcifs/" rel="alternate" />
        <content type="html"><![CDATA[
            <h2>Простые примеры работы с самбой при помощи JCIFS</h2>

<p>Ниже показан пример класса для копирования файла на самба-шару и просмотра содержимого заданной шары</p>

<pre><code>import jcifs.Config;
import jcifs.smb.*;
import java.io.*;

public class SambaTest {
  // Нормальный конструктор я тут делать не буду, для тестового примера это не нужно
static final String USER_NAME = &quot;username&quot;;
static final String PASSWORD = &quot;password&quot;;
static final String DOMAIN = &quot;user_domain&quot;;

// Путь к сетевой папке с которой будем работать
static final String NETWORK_FOLDER = &quot;smb://server/share/&quot;;


// Копируем файл на шару.
// К сожалению SmbFile ничего не знает о методе copyTo из File,
// так что придется этот метод эмулировать руками. Халява не прокатила :(
// В обратную сторону все тоже самое, только потоки будут в обратную сторону.
public boolean copyFileToSamba(String srcFilePath, String destPath) {
    boolean successful = false;
    try{
        // Создаем объект аутентификатор
        NtlmPasswordAuthentication auth =
          new NtlmPasswordAuthentication(DOMAIN, USER_NAME, PASSWORD);

        // Читаем содержимое исходного файла
        File srcFile = new File(srcFilePath);
        InputStream localFile = new FileInputStream(srcFile);

        // Создаем объект для потока куда мы будем писать наша файл
        SmbFileOutputStream destFileName = new SmbFileOutputStream(
          new SmbFile(destPath+File.separator+srcFile.getName(), auth));

        // Ну и копируем все из исходного потока в поток назначения.
        BufferedReader brl = new BufferedReader(
          new InputStreamReader(localFile));
        String b = null;
        while((b=brl.readLine())!=null){
            destFileName.write(b.getBytes());
        }
        destFileName.flush();


        successful = true;
    } catch (Exception e) {
        successful = false;
        e.printStackTrace();
    }
    return successful;
}

// Читаем
public boolean readShareContent() {
    boolean successful = false;
    try{
        // Создаем объект для аутентификации на шаре
        NtlmPasswordAuthentication auth =
          new NtlmPasswordAuthentication(DOMAIN, USER_NAME, PASSWORD);
        String path = NETWORK_FOLDER;

        // Ресолвим путь назначения в SmbFile
        SmbFile baseDir = new SmbFile(path, auth);

        // Вычитываем все содержимое шары в массив
        SmbFile[] files = baseDir.listFiles();

        // Делаем что-нибудь со списком файлов
        for (int i = 0; i &lt; files.length; i++) {
          SmbFile file = files[i];
          if (file.isDirectory()) {
                System.out.println(&quot;Is DIR: &quot;+file.toString());
                continue;
          } else {
                System.out.println(&quot;Is FILE: &quot;+file.toString());
          }
        }

        successful = true;
    } catch (Exception e) {
        successful = false;
        e.printStackTrace();
    }
    return successful;
  }
}
</code></pre>

<p>Если все работы с шарой невероятно тупят - то нужно сменить режим ресолвинга сервера и шары.</p>

<p>В конструктор добавляем следующее:</p>

<pre><code>Config.setProperty( &quot;jcifs.resolveOrder&quot;, &quot;DNS&quot;);
</code></pre>

<p>Этим мы указываем что ресолвить имя сервера мы будем ТОЛЬКО через DNS. Можно туда добавить всякие NetBIOS и прочее, но на практике я с необходимостью это делать не сталкивался. Естественно, что если у вас в сети нет локального DNS сервера который будет ресолвить именя локальным машин - то механизм надо сменить на другой. Выбор механизмов ресолвинга будет проходить в порядке указанном в конфиге.</p>

<p>Если предполагается копирование больших бинарных файлов, то код копирования надо заменить с:</p>

<p>BufferedReader brl = new BufferedReader(new InputStreamReader(localFile));
  String b = null;
  while((b=brl.readLine())!=null){
    destFileName.write(b.getBytes());
  }</p>

<p>на:</p>

<p>byte[] buffer = new byte[1024000];
  int noOfBytes = 0;</p>

<p>while ((noOfBytes = localFile.read(buffer)) != -1) {
    destFileName.write(buffer, 0, noOfBytes);
  }</p>

<p>Если этого не сделать - то большие файлы будут копироваться криво.</p>

                <p><a href="http://alpha6.ru/blog/2016/08/07/java-jcifs/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://alpha6.ru/blog/tag/java/">java</a>
                <a href="http://alpha6.ru/blog/tag/jcifs/">jcifs</a>
                <a href="http://alpha6.ru/blog/tag/samba/">samba</a>
            </p>
        ]]></content>
        <updated>2016-08-07T00:00:00Z</updated>
        <category term="java" />
        <category term="jcifs" />
        <category term="samba" />
    </entry>
</feed>

