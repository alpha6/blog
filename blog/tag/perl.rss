<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Just another blog</title>
        <link>http://alpha6.ru/blog/tag/perl/</link>
        <atom:link href="http://alpha6.ru/blog/tag/perl.rss" rel="self" type="application/rss+xml" />
        <description>Blog feed of Just another blog</description>
        <generator>Statocles 0.083</generator>
        <item>
            <title>Асинхронная работа с COM-портом в Perl</title>
            <link>http://alpha6.ru/blog/2017/05/28/async-serial-port/</link>
            <guid>http://alpha6.ru/blog/2017/05/28/async-serial-port/</guid>
            <description><![CDATA[
                <p>Понадобилось мне тут поработать с 3d принтером из Perl. Принтер подключается к компьютеру через USB-COM переходник и прикидывается обычным COM портом со всеми вытекающими способами работы.</p>

<p>Для работы с ком-портом в Perl есть отличный модуль - <a href="https://metacpan.org/pod/Device::SerialPort">Device::SerialPort</a>. А для асинхронности используем классический AnyEvent. Ну и долго сказка сказывается, да быстро код пишется - пример кода:</p>

<pre><code>#!/usr/bin/env perl

use v5.20;
use strict;

use AnyEvent;
use AnyEvent::Handle;

use Device::SerialPort;

my $cv = AE::cv;

# Базовые параметры подключения к порту
my $device_port = &#39;/dev/ttyUSB0&#39;;
my $port_speed  = 115200;

say &quot;Connecting.. [$device_port] [$port_speed]&quot;;
my $port = Device::SerialPort-&gt;new($device_port);
$port-&gt;baudrate($port_speed); #Устанавливаем скорость соединения

# Чуть более продвинутые настройки
$port-&gt;handshake(&quot;none&quot;); #Не используем handshake иначе подключение будет устанавливаться только в момент перезагрузки принтера

# Режим коммуникации 8N1
$port-&gt;databits(8);
$port-&gt;parity(&quot;none&quot;);
$port-&gt;stopbits(1);

$port-&gt;stty_echo(0); # Выключаем эхо
$port-&gt;error_msg(&#39;ON&#39;); # Включаем выдачу ошибок от порта

# Получаем чистый хэндлер порта и с ним создаем объект AE::Handle
my $fh = $port-&gt;{&#39;HANDLE&#39;};

my $handle;
$handle = AnyEvent::Handle-&gt;new(
fh       =&gt; $fh,
on_error =&gt; sub {
    my ( $handle, $fatal, $message ) = @_;
    $handle-&gt;destroy;
    undef $handle;
    say STDERR &quot;$fatal : $message\n&quot;;
},
on_read =&gt; sub {
    my $printer_handle = shift;
    $handle-&gt;push_read(
        line =&gt; sub {
            my ( $printer_handle, $line ) = @_;
            say sprintf( &quot;Reply: [%s]&quot;, $line );
        }
    );
}
);

# Отправляем команду принтеру
$port-&gt;write(&quot;M105\n&quot;);

$cv-&gt;recv;
</code></pre>

<p>После запуска (если все параметры указаны верно) получим такой вывод:</p>

<pre><code>Connecting.. [/dev/ttyUSB0] [115200]
Reply: [ok T:26.6 /0.0 @:0]
</code></pre>

<p>Подключение к принтеру и передача данных в обе стороны прошли успешно!</p>

<p><strong>Важный нюанс!</strong></p>

<p>Хэндлер порта полученный тут <code>my $fh = $port-&gt;{&#39;HANDLE&#39;};</code> <strong>однонаправленный на чтение</strong>! Если попытаться туда что-то записать силами AE то получим ошибку. Писать надо напрямую в объект порта, что и происходит в предпоследней строке.</p>


                    <p>Tags:
                        <a href="http://alpha6.ru/blog/tag/anyevent/">AnyEvent</a>
                        <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                        <a href="http://alpha6.ru/blog/tag/serial-port/">serial port</a>
                        <a href="http://alpha6.ru/blog/tag/hardware/">hardware</a>
                    </p>

            ]]></description>
            <pubDate>
                Sun, 28 May 2017 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Отправляем емейл из Perl с авторизацией и html</title>
            <link>http://alpha6.ru/blog/2016/09/08/send-html-email-with-perl/</link>
            <guid>http://alpha6.ru/blog/2016/09/08/send-html-email-with-perl/</guid>
            <description><![CDATA[
                <p>Отправляем письмо в html с авторизацией из Perl.</p>

<pre><code>use strict;
use Net::SMTP;
use Authen::SASL; #нужен для авторизации

use utf8;
use Encode;
use MIME::Base64


  my $message = &quot;&lt;html&gt;&lt;body&gt;Тестовое письмо&lt;/body&gt;&lt;/html&gt;&quot;;

# авторизационные данные
my $smtp_host = &#39;smtp.server.address&#39;;
my $smtp_user = &#39;user_name&#39;;
my $smtp_pass = &#39;password&#39;;


my $debug = 1; # рассматриваем процесс подключения в деталях

# mail properties
my $mail_from = &#39;user@example.com&#39;;
my $mail_to = &#39;recipient@example.com&#39;;
my $mail_subject = &#39;Тестовое письмо&#39;;

# Выставляем заголовки. Сюда можно добавить еще всякого при необходимости
my $mail_headers = &quot;From: $mail_from\n&quot;.
&quot;To: $mail_to\n&quot;.
&quot;Subject: &quot;.encode(&#39;MIME-Header&#39;,$mail_subject).&quot;\n&quot;.
&quot;MIME-Version: 1.0\n&quot;.
&quot;Content-type: text/html; charset=UTF-8\n&quot;.
&quot;Content-Transfer-Encoding: base64\n\n&quot;;

my $mail_body = $message;

# Отправляем письмо
my $smtp = Net::SMTP-&gt;new($smtp_host, Debug =&gt; $debug) or die &quot;cannot connect to server&quot;;
$smtp-&gt;auth($smtp_user,$smtp_pass) or die &quot;could not authenticate&quot;;
$smtp-&gt;mail($mail_from);
$smtp-&gt;to($mail_to);
$smtp-&gt;data();
$smtp-&gt;datasend($mail_headers);
$smtp-&gt;datasend(encode_base64(encode(&#39;UTF-8&#39;, $mail_body)));
$smtp-&gt;dataend();
$smtp-&gt;quit;
</code></pre>

<p>При необходимости можно добавить файлы, PGP подписи и так далее.</p>


                    <p>Tags:
                        <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                        <a href="http://alpha6.ru/blog/tag/net-smtp/">net::smtp</a>
                        <a href="http://alpha6.ru/blog/tag/email/">email</a>
                    </p>

            ]]></description>
            <pubDate>
                Thu, 08 Sep 2016 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>State переменные в Perl</title>
            <link>http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/</link>
            <guid>http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/</guid>
            <description><![CDATA[
                <p>В Perl существует особый тип переменных под названием state.</p>

<p>В <a href="http://perldoc.perl.org/functions/state.html">доке</a> про них написано:</p>

<blockquote>
  <p>state declares a lexically scoped variable, just like my. However, those variables will never be reinitialized ...</p>
</blockquote>

<p>На первый взгляд это дает нам возможность очень просто реализовывать счетчики и иже с ними:</p>

<pre><code>sub count {
  state $count = 0;
  $count++;
}
</code></pre>

<p>Однако, есть нюанс - фраза <em>will never be reinitialized</em> означает что переменная действительно никогда не будет переинициализирована пока существует родительский скрипт. И это дает нам вот такую замечательную граблю на которую можно ненароком наступить:</p>

<p>Объявляем пакет:</p>

<pre><code>package MyTestState;

use strict;
use feature &#39;state&#39;;

sub new {
  bless {}, shift;
}

sub count {
  state $count = 0;
  $count++;
}

1;
</code></pre>

<p>И саму программу:</p>

<pre><code>use lib &#39;lib&#39;;
use v5.18;
use MyTestState;

my $mystate =  MyTestState-&gt;new();

for (0..10) {
  my $counter = $mystate-&gt;count();
  say &quot;Counter [$counter]&quot;;
}
</code></pre>

<p>Вывод ожидаем:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
</code></pre>

<p>А теперь добавляем такой код:</p>

<pre><code>undef $mystate;

say &quot;next object!=======&quot;;

my $mystate1 = MyTestState-&gt;new();
for (0..10) {
  my $counter = $mystate1-&gt;count();
  say &quot;Counter [$counter]&quot;;

}
</code></pre>

<p>Здесь мы удаляем старый объект со счетчиком и создаем новый. Логично предположить что счетчик пойдет заново, но на самом деле нет. Не смотря на то что мы удалили старый объект и создали новый, переменная со счетчиком никуда не делась и не была переиницализирована! И при запуске программы мы увидим:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
next object!
Counter [11]
Counter [12]
Counter [13]
...
Counter [20]
Counter [21]
</code></pre>

<p>Так что слово <code>newer</code> в документации действительно значит &quot;никогда пока жив инстанс интерпретатора запустивший скрипт&quot;.</p>


                    <p>Tags:
                        <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                        <a href="http://alpha6.ru/blog/tag/state/">state</a>
                        <a href="http://alpha6.ru/blog/tag/trap/">trap</a>
                    </p>

            ]]></description>
            <pubDate>
                Sat, 26 Dec 2015 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>DBD::Pg install</title>
            <link>http://alpha6.ru/blog/2015/09/19/dbd-pg-install/</link>
            <guid>http://alpha6.ru/blog/2015/09/19/dbd-pg-install/</guid>
            <description><![CDATA[
                <p>Markdown content goes here.</p>

<p>Если при установке <code>DBD::Pg</code> через <code>CPAN</code> у вас начинают спрашивать какие-то странные слова про номер версии и расположение директорий Postgresql - проверьте что у вас установлен пакет <code>postgresql-server-dev-X.X</code> (<code>postgresql-server-dev-all</code>).</p>

<p>После его установки проблема магическим (на самом деле нет) образом исчезает.</p>


                    <p>Tags:
                        <a href="http://alpha6.ru/blog/tag/ubuntu/">ubuntu</a>
                        <a href="http://alpha6.ru/blog/tag/postgresql/">postgresql</a>
                        <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                        <a href="http://alpha6.ru/blog/tag/dbd-pg/">dbd::pg</a>
                    </p>

            ]]></description>
            <pubDate>
                Sat, 19 Sep 2015 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Получение методов пакета</title>
            <link>http://alpha6.ru/blog/2015/09/14/get-package-methods/</link>
            <guid>http://alpha6.ru/blog/2015/09/14/get-package-methods/</guid>
            <description><![CDATA[
                <p>Для получения методов пакета Foo::Bar делаем:</p>

<pre><code>print Dumper(\%Foo::Bar::);
</code></pre>

<p>Для проверки существования метода:</p>

<pre><code>if (Foo::Bar::.$method_name) {
    #some stuff
}
</code></pre>

<p>Для получения методов текущего пакета:</p>

<pre><code>print Dumper(\%main::)
</code></pre>

<p>Но если подключены дополнительные библиотеки - в выводе будут методы всех подключенных библиотек.</p>

<p><a href="http://perldoc.perl.org/perlmod.html#Symbol-Tables">Подробнее в документации</a></p>


                    <p>Tags:
                        <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                        <a href="http://alpha6.ru/blog/tag/note/">note</a>
                        <a href="http://alpha6.ru/blog/tag/package/">package</a>
                    </p>

            ]]></description>
            <pubDate>
                Mon, 14 Sep 2015 00:00:00 +0000
            </pubDate>
        </item>
    </channel>
</rss>

