<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Just another blog</title>
        <link>http://alpha6.ru/blog/tag/perl/</link>
        <atom:link href="http://alpha6.ru/blog/tag/perl.rss" rel="self" type="application/rss+xml" />
        <description>Blog feed of Just another blog</description>
        <generator>Statocles 0.061</generator>
        <item>
            <title>State переменные в Perl</title>
            <link>http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/</link>
            <guid>http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/</guid>
            <description><![CDATA[
                <p>В Perl существует особый тип переменных под названием state.</p>

<p>В <a href="http://perldoc.perl.org/functions/state.html">доке</a> про них написано:</p>

<blockquote>
  <p>state declares a lexically scoped variable, just like my. However, those variables will never be reinitialized ...</p>
</blockquote>

<p>На первый взгляд это дает нам возможность очень просто реализовывать счетчики и иже с ними:</p>

<pre><code>sub count {
  state $count = 0;
  $count++;
}
</code></pre>

<p>Однако, есть нюанс - фраза <em>will never be reinitialized</em> означает что переменная действительно никогда не будет переинициализирована пока существует родительский скрипт. И это дает нам вот такую замечательную граблю на которую можно ненароком наступить:</p>

<p>Объявляем пакет:</p>

<pre><code>package MyTestState;

use strict;
use feature &#39;state&#39;;

sub new {
  bless {}, shift;
}

sub count {
  state $count = 0;
  $count++;
}

1;
</code></pre>

<p>И саму программу:</p>

<pre><code>use lib &#39;lib&#39;;
use v5.18;
use MyTestState;

my $mystate =  MyTestState-&gt;new();

for (0..10) {
  my $counter = $mystate-&gt;count();
  say &quot;Counter [$counter]&quot;;
}
</code></pre>

<p>Вывод ожидаем:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
</code></pre>

<p>А теперь добавляем такой код:</p>

<pre><code>undef $mystate;

say &quot;next object!=======&quot;;

my $mystate1 = MyTestState-&gt;new();
for (0..10) {
  my $counter = $mystate1-&gt;count();
  say &quot;Counter [$counter]&quot;;

}
</code></pre>

<p>Здесь мы удаляем старый объект со счетчиком и создаем новый. Логично предположить что счетчик пойдет заново, но на самом деле нет. Не смотря на то что мы удалили старый объект и создали новый, переменная со счетчиком никуда не делась и не была переиницализирована! И при запуске программы мы увидим:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
next object!
Counter [11]
Counter [12]
Counter [13]
...
Counter [20]
Counter [21]
</code></pre>

<p>Так что слово <code>newer</code> в документации действительно значит &quot;никогда пока жив инстанс интерпретатора запустивший скрипт&quot;.</p>

                    <p><a href="http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/state/">state</a>
                    <a href="http://alpha6.ru/blog/tag/trap/">trap</a>
                </p>
            ]]></description>
            <pubDate>
                Sat, 26 Dec 2015 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Получение методов пакета</title>
            <link>http://alpha6.ru/blog/2015/09/14/get-package-methods/</link>
            <guid>http://alpha6.ru/blog/2015/09/14/get-package-methods/</guid>
            <description><![CDATA[
                <p>Для получения методов пакета Foo::Bar делаем:</p>

<pre><code>print Dumper(\%Foo::Bar::);
</code></pre>

<p>Для проверки существования метода:</p>

<pre><code>if (Foo::Bar::.$method_name) {
    #some stuff
}
</code></pre>

<p>Для получения методов текущего пакета:</p>

<pre><code>print Dumper(\%main::)
</code></pre>

<p>Но если подключены дополнительные библиотеки - в выводе будут методы всех подключенных библиотек.</p>

<p><a href="http://perldoc.perl.org/perlmod.html#Symbol-Tables">Подробнее в документации</a></p>

                    <p><a href="http://alpha6.ru/blog/2015/09/14/get-package-methods/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/note/">note</a>
                    <a href="http://alpha6.ru/blog/tag/package/">package</a>
                </p>
            ]]></description>
            <pubDate>
                Mon, 14 Sep 2015 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Используем Graylog с Perl</title>
            <link>http://alpha6.ru/blog/2015/04/30/using-perl-and-graylog/</link>
            <guid>http://alpha6.ru/blog/2015/04/30/using-perl-and-graylog/</guid>
            <description><![CDATA[
                <p>Устанавливаем Graylog. Для опытов я использовал преднастроенную VM для VirtualBox http://docs.graylog.org/en/1.0/pages/installation.html#virtual-machine-appliances</p>

<p>! На момент написания статьи в VM идет версия Graylog-web с багом - при создании dashboard на нее нельзя добавить виджет т.к. JS-скрипт ответственный за разблокировку dashboard падает с ошибкой. Что-бы что-то сделать с дэшбордом на него надо добавить любой виджет с любой страницы. Это делается по клику на иконку возле названия виджета и выбором нужного дэшборда.</p>

<p>Первым делом надо создать Input для логов.
Мы будем использовать GELF формат через Log::Log4perl.
Идем System-&gt;Inputs в выпадающем списке выбираем GELF UDP и жмем Launch Input.
В открывшемся окне выбираем ноды на которых будет работать этот инпут, описание, адрес на котором он будет слушать.
Жмем launch, убеждаемся что он стартанул и на этом пока все работы с Graylog закончены.</p>

<p>Теперь устанавливаем пакет <a href="https://metacpan.org/pod/Log::Log4perl::Layout::GELF">Log::Log4perl::Layout::GELF</a>.</p>

<p>Создаем файл конфигурации логгера:</p>

<pre><code>log4perl.logger.graylog                     = INFO, Screen, Graylog

log4perl.appender.Screen                = Log::Log4perl::Appender::Screen
log4perl.appender.Screen.stderr         = 0
log4perl.appender.Screen.layout         = Log::Log4perl::Layout::PatternLayout
log4perl.appender.Screen.layout.ConversionPattern = [%d] [%p] %m%n
log4perl.appender.Screen.utf8           = 1

log4perl.appender.Graylog          = Log::Log4perl::Appender::Socket
log4perl.appender.Graylog.PeerAddr = graylog.host
log4perl.appender.Graylog.PeerPort = 12201
log4perl.appender.Graylog.Proto    = udp
log4perl.appender.Graylog.layout   = GELF
</code></pre>

<p>Создаем тестовый скрипт:</p>

<pre><code>#!/usr/bin/env perl

use utf8;
use strict;
use Log::Log4perl;

#Загружаем конфигурацию 
Log::Log4perl::init(&#39;logger.conf&#39;);

#Получаем логгер
my $logger = Log::Log4perl-&gt;get_logger(&#39;graylog&#39;);

$logger-&gt;info(&#39;hello graylog&#39;);
$logger-&gt;info(&#39;Тестовое сообщение UTF8&#39;);
</code></pre>

<p>В теории, этого достаточно для того что бы нужные логи вашего приложения начали идти в Graylog. Но, как обычно, есть нюанс - этот модуль совершенно не представляет что есть более чем однобайтные кодировки и при попытке что-то записать в лог что-то с utf8 мы получим ошибку <code>Wide character in IO::Compress::Gzip::write</code> и в Graylog сообщение не придет.</p>

<p>Для обычных аппендеров, например Screen, эта проблема решается просто - дописываем в конфигурацию флаг включения utf8:</p>

<pre><code>log4perl.appender.FileAppndr.utf8     = 1
</code></pre>

<p>Но в данном случае проблема на уровне layout и этот модуль не обрабатывает такую ситуацию.</p>

<p>Для себя я эту проблему решил просто - сделал форк модуля с названием <a href="https://github.com/alpha6/Log-Log4perl-Layout-GELFUtf">GELFUtf</a> и использую его.</p>

<p>Таким образом в конфиге вместо <code>log4perl.appender.Graylog.layout   = GELF</code> пишу <code>log4perl.appender.Graylog.layout   = GELFUtf</code>.</p>

<p>Подменить фунцию на лету у меня не получилось, скорее всего из-за хитрой архитектуры Log4perl. А лезть патчить в рантайм - овчинка выделки не стоит. Так что пока пользуюсь патченым модулем и коплю силы на создание полноценного патча для оригинального модуля.</p>

                    <p><a href="http://alpha6.ru/blog/2015/04/30/using-perl-and-graylog/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/graylog/">graylog</a>
                </p>
            ]]></description>
            <pubDate>
                Thu, 30 Apr 2015 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>stdout autoflush</title>
            <link>http://alpha6.ru/blog/2015/04/25/stdout-autoflush/</link>
            <guid>http://alpha6.ru/blog/2015/04/25/stdout-autoflush/</guid>
            <description><![CDATA[
                <p>Классический метод:</p>

<pre><code>$oldfh = select(STDERR); $| = 1; select($oldfh);
</code></pre>

<p>ООП:</p>

<pre><code>use IO::Handle;
STDERR-&gt;autoflush(1);
</code></pre>

                    <p><a href="http://alpha6.ru/blog/2015/04/25/stdout-autoflush/#section-2">Continue reading...</a></p>
                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/snippet/">snippet</a>
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/io/">io</a>
                </p>
            ]]></description>
            <pubDate>
                Sat, 25 Apr 2015 00:00:00 +0000
            </pubDate>
        </item>
    </channel>
</rss>

