<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alpha6.ru/blog/tag/perl/</id>
    <title>Just another blog</title>
    <updated>2017-07-04T00:00:00Z</updated>
    <link href="http://alpha6.ru/blog/tag/perl.atom" rel="self" />
    <link href="http://alpha6.ru/blog/tag/perl/" rel="alternate" />
    <generator version="0.083">Statocles</generator>

    <entry>
        <id>http://alpha6.ru/blog/2017/07/04/installing-convos/</id>
        <title>Installing Convos</title>
        <link href="http://alpha6.ru/blog/2017/07/04/installing-convos/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Современные технологии это всегда хорошо, но и нестареющая классика на то и классика чтобы про нее не забывать. В данном случае я говорю об IRC.
IRC прекрасная технология, вот только мобильные клиенты для него отличаются кривостью и нестабильностью работы. А уж зайти в IRC из корпоративных сетей может быть еще тем квестом.
Плюс особенностью IRC является тот факт, что никакой истории сообщений там не хранится и все что было в ваше отсутствие на канале пройдет мимо вас.
Частично решить первую проблему и полностью вторую и третью предназначен Convos.</p>

<p>Это веб интерфейс для IRC. Умеет поддерживать много соединений. Хранит историю и дает приятный веб-интерфейс неплохо работающий на смартфонах.</p>

<p>Будем ставить его из гита на свой сервер. Для таких целей я использую OpenVZ сервера от <a href="https://billing.time4vps.eu/?affid=1845">Time4vps</a>. Серваки в Европе, стоят дешево, работают достаточно шустро и стабильно. Для наших целей достаточно самого дешевого.</p>

<p>Считаем что сервер у нас есть и даже с доменным именем.</p>

<p>Настроим SSL, нам он нужен только для того что-бы наш трафик не читал кто попало, так что хватит сертификата от LetsEncript. Тем более что получение и обновление сертификата нынче автоматизировано во всех более-менее современных дистрибутивах.</p>

<h1>Настраиваем nginx и SSL</h1>

<p>Устанавливаем certbot:</p>

<pre><code>apt-get install certbot
</code></pre>

<p>Зарегистрируемся в сервисе (надо сделать один раз):</p>

<pre><code>certbot register --email me@example.com
</code></pre>

<p>Настроим nginx для поддержки автоматического обновления сертификатов:</p>

<pre><code>mkdir -p /var/www/html/.well-known/acme-challenge
echo Success &gt; /var/www/html/.well-known/acme-challenge/example.html
</code></pre>

<p>Создадим инклюд для нашего локейшена для обновления сертификатов:</p>

<pre><code>vim /etc/nginx/acme

location /.well-known {
    root /var/www/html;
}
</code></pre>

<p>Заворачиваем все запросы (кроме обновления сертификатов) на https:</p>

<pre><code>vim /etc/nginx/sites-aviable/default

server {
    listen 80 default_server;

    include acme;

    location / {
        return 301 https://$host$request_uri;
    }
}
</code></pre>

<p>Перезагружаем nginx и проверяем что локейшен доступен:</p>

<pre><code>service nginx reload

curl -L http://irc.alpha6.ru/.well-known/acme-challenge/example.html
Success
</code></pre>

<p>Удаляем файл который мы создали для теста:</p>

<pre><code>rm http://irc.alpha6.ru/.well-known/acme-challenge/example.html
</code></pre>

<p>В принципе он ни на что не влияет, но с ним certbot будет ругаться что не удалось удалить все лишнее после обновления сертификатов.</p>

<p>Создаем конфиг файл для certbot, чтобы не задавал лишних вопросов и работал автоматом:</p>

<pre><code>vim /etc/letsencrypt/cli.ini

authenticator = webroot
webroot-path = /var/www/html
post-hook = service nginx reload
text = True
agree-tos = True
email = imdefined@yandex.ru
</code></pre>

<p>Проверяем что все работает как надо:</p>

<pre><code>certbot certonly --dry-run -d irc.alpha6.ru

Saving debug log to /var/log/letsencrypt/letsencrypt.log
Starting new HTTPS connection (1): acme-staging.api.letsencrypt.org
Cert not due for renewal, but simulating renewal for dry run
Renewing an existing certificate
Performing the following challenges:
http-01 challenge for irc.alpha6.ru
Using the webroot path /var/www/html for all unmatched domains.
Waiting for verification...
Cleaning up challenges
Unable to clean up challenge directory /var/www/html/.well-known/acme-challenge
Generating key (2048 bits): /etc/letsencrypt/keys/0004_key-certbot.pem
Creating CSR: /etc/letsencrypt/csr/0004_csr-certbot.pem
Running post-hook command: service nginx reload

IMPORTANT NOTES:
- The dry run was successful.
- If you lose your account credentials, you can recover through
e-mails sent to imdefined@yandex.ru.
- Your account credentials have been saved in your Certbot
configuration directory at /etc/letsencrypt. You should make a
secure backup of this folder now. This configuration directory will
also contain certificates and private keys obtained by Certbot so
making regular backups of this folder is ideal.
</code></pre>

<p>Все ок, получаем полноценный сертификат:</p>

<pre><code>certbot certonly -d irc.alpha6.ru

Saving debug log to /var/log/letsencrypt/letsencrypt.log
Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
Obtaining a new certificate
Performing the following challenges:
http-01 challenge for irc.example.com
Using the webroot path /var/www/html for all unmatched domains.
Waiting for verification...
Cleaning up challenges
Generating key (2048 bits): /etc/letsencrypt/keys/0004_key-certbot.pem
Creating CSR: /etc/letsencrypt/csr/0004_csr-certbot.pem

IMPORTANT NOTES:
    - Congratulations! Your certificate and chain have been saved at
    /etc/letsencrypt/live/irc.example.com/fullchain.pem. Your cert will
    expire on 2017-10-09. To obtain a new or tweaked version of this
    certificate in the future, simply run certbot again. To
    non-interactively renew *all* of your certificates, run &quot;certbot
    renew&quot;
</code></pre>

<p>Теперь создадим конфиг nginx для сервиса:</p>

<pre><code>vim /etc/nginx/sites-available/irc.example.com

server {
    listen 443 ssl;

    ssl on;
    ssl_stapling on;

    server_name irc.alpha6.ru;

    ssl_certificate     /etc/letsencrypt/live/irc.alpha6.ru/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/irc.alpha6.ru/privkey.pem;

    ssl_ciphers &#39;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&#39;;
    ssl_prefer_server_ciphers on;

    ssl_dhparam /etc/nginx/conf.d/dhparams.pem;

    error_log  /var/log/nginx/irc.alpha6.ru.error.log error;


    include acme;

    location / {
        proxy_pass      http://127.0.0.1:3001;
        access_log     /var/log/nginx/irc.alpha6.ru.log combined;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;

        # Enable Convos to construct correct URLs by passing on custom
        # headers. X-Request-Base is only required if &quot;location&quot; above
        # is not &quot;/&quot;.
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

    }

}
</code></pre>

<p>Активируем этот сайт:</p>

<pre><code>ln -s /etc/nginx/sites-available/irc.example.com /etc/nginx/sites-enabled/
</code></pre>

<p>Сгенерим усиленные параметры шифрования для DHE:</p>

<pre><code>openssl dhparam -out /etc/ssl/private/dhparam.pem 2048
</code></pre>

<p>Добавим их в конфигурацию nginx:</p>

<pre><code>vim /etc/nginx/conf.d/ssl_parameters.conf

ssl_dhparam /etc/ssl/private/dhparams.pem;
</code></pre>

<p>Перезапускаем nginx и наслаждаемся ошибкой 502 по тому адресу где должен быть сайт :)</p>

<pre><code>service nginx restart
</code></pre>

<h1>Настроим firewall</h1>

<p>Создадим system.d сервис который будет поднимать firewall при старте сети:</p>

<pre><code>vim /etc/systemd/system/firewall.service

[Unit]
Description=Add Firewall Rules to iptables

[Service]
Type=oneshot
ExecStart=/etc/firewall/enable.sh

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Firewall я тут привожу самый простой, блокирует доступ ко всем портам кроме 22, 80, 443 и всех выпускает наружу:</p>

<pre><code>vim /etc/firewall/enable.sh

#!/bin/sh

# iptables script generated 2017-07-04
# http://www.mista.nu/iptables

IPT=&quot;/sbin/iptables&quot;

# Flush old rules, old custom tables
$IPT --flush
$IPT --delete-chain

# Set default policies for all three default chains
$IPT -P INPUT DROP
$IPT -P FORWARD DROP
$IPT -P OUTPUT ACCEPT

# Enable free use of loopback interfaces
$IPT -A INPUT -i lo -j ACCEPT
$IPT -A OUTPUT -o lo -j ACCEPT

# All TCP sessions should begin with SYN
$IPT -A INPUT -p tcp ! --syn -m state --state NEW -s 0.0.0.0/0 -j DROP

# Accept inbound TCP packets
$IPT -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPT -A INPUT -p tcp --dport 22 -m state --state NEW -s 0.0.0.0/0 -j ACCEPT
$IPT -A INPUT -p tcp --dport 80 -m state --state NEW -s 0.0.0.0/0 -j ACCEPT
$IPT -A INPUT -p tcp --dport 443 -m state --state NEW -s 0.0.0.0/0 -j ACCEPT
</code></pre>

<h1>Поднимаем сервис Convos</h1>

<p>Создадим пользователя convos. От его имени будет работать сервис.</p>

<p>Устанавливаем <a href="https://perlbrew.pl">perlbrew</a> (Этот шаг можно пропустить если у вас относительно свежий дистрибутив, но я предпочитаю контролировать среду где у меня работает софт).
Perlbrew ставим от root в систему чтобы он был виден все пользователям:</p>

<pre><code>apt-get install perlbrew
perlbrew init
source /opt/perlbrew/etc/bashrc

echo source /opt/perlbrew/etc/bashrc &gt;&gt; /etc/bash.bashrc
</code></pre>

<p>Устанавливаем perl 5.24.1 и переключаемся на него чтобы поставить пару модулей (на момент написания статьи Convos не ставился на 5.26 из-за ошибки в одном из сторонних модулей).</p>

<pre><code>perlbrew install perl-5.24.1
perlbrew use perl-5.24.1
cpan -i Carton
</code></pre>

<p>После установки perl и Carton можно настраивать все дальше.</p>

<p>Для начала создадим system.d сервис который будет поднимать наш сервис после старта nginx (потому что если nginx не поднялся все равно ничего работать не будет).</p>

<pre><code>vim /etc/systemd/system/convos.service

[Unit]
After=nginx.service
Description=ConvosService

[Service]
ExecStart=/srv/convos/start.sh
WorkingDirectory=/srv/convos
User=convos
Group=convos
Restart=always

[Install]
WantedBy=default.target
</code></pre>

<p>Клонируем convos из гита в /srv/convos</p>

<pre><code>cd /srv/
git clone https://github.com/Nordaaker/convos.git
</code></pre>

<p>Переключаемся на пользователя convos и ставим все зависимости через Carton:</p>

<pre><code>su convos
cd /srv/convos 
export PERLBREW_ROOT=/opt/perlbrew
export PERLBREW_HOME=/srv/convos/.perlbrew_convos
source ${PERLBREW_ROOT}/etc/bashrc

carton install
</code></pre>

<p>После того как поставятся все зависимости создадим враппер для запуска сервиса Convos</p>

<pre><code>vim /srv/convos/start.sh 
#!/bin/bash

## These 3 lines are mandatory.
export PERLBREW_ROOT=/opt/perlbrew
export PERLBREW_HOME=/srv/convos/.perlbrew_convos
source ${PERLBREW_ROOT}/etc/bashrc

## Do stuff with 5.24.1
perlbrew use 5.24.1
export MOJO_REVERSE_PROXY=1
#export CONVOS_DEBUG=1
carton exec ./script/convos daemon --listen http://127.0.0.1:3001
</code></pre>

<p>Активируем сервис system.d и проверяем его статус: </p>

<pre><code>systemctl enable convos
systemctl -l status convos
</code></pre>

<p>Для начала лучше запустить враппер руками от пользователя convos и убедится что нет ошибок запуска (заодно посмотреть инвайт код для регистрации через веб).</p>

<p>Если все в порядке - то запускаем сервис через system.d и наслаждаемся прогрессивной работой в IRC. </p>

<p>Если сервис таки не запустился, то посмотреть ошибки можно командой:</p>

<pre><code>journalctl -u convos -f
</code></pre>

<h2>Make the IRC great again!</h2>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/convos/">convos</a>
                    <a href="http://alpha6.ru/blog/tag/irc/">irc</a>
                </p>

        ]]></content>
        <updated>2017-07-04T00:00:00Z</updated>
        <category term="perl" />
        <category term="convos" />
        <category term="irc" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2017/05/28/async-serial-port/</id>
        <title>Асинхронная работа с COM-портом в Perl</title>
        <link href="http://alpha6.ru/blog/2017/05/28/async-serial-port/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Понадобилось мне тут поработать с 3d принтером из Perl. Принтер подключается к компьютеру через USB-COM переходник и прикидывается обычным COM портом со всеми вытекающими способами работы.</p>

<p>Для работы с ком-портом в Perl есть отличный модуль - <a href="https://metacpan.org/pod/Device::SerialPort">Device::SerialPort</a>. А для асинхронности используем классический AnyEvent. Ну и долго сказка сказывается, да быстро код пишется - пример кода:</p>

<pre><code>#!/usr/bin/env perl

use v5.20;
use strict;

use AnyEvent;
use AnyEvent::Handle;

use Device::SerialPort;

my $cv = AE::cv;

# Базовые параметры подключения к порту
my $device_port = &#39;/dev/ttyUSB0&#39;;
my $port_speed  = 115200;

say &quot;Connecting.. [$device_port] [$port_speed]&quot;;
my $port = Device::SerialPort-&gt;new($device_port);
$port-&gt;baudrate($port_speed); #Устанавливаем скорость соединения

# Чуть более продвинутые настройки
$port-&gt;handshake(&quot;none&quot;); #Не используем handshake иначе подключение будет устанавливаться только в момент перезагрузки принтера

# Режим коммуникации 8N1
$port-&gt;databits(8);
$port-&gt;parity(&quot;none&quot;);
$port-&gt;stopbits(1);

$port-&gt;stty_echo(0); # Выключаем эхо
$port-&gt;error_msg(&#39;ON&#39;); # Включаем выдачу ошибок от порта

# Получаем чистый хэндлер порта и с ним создаем объект AE::Handle
my $fh = $port-&gt;{&#39;HANDLE&#39;};

my $handle;
$handle = AnyEvent::Handle-&gt;new(
fh       =&gt; $fh,
on_error =&gt; sub {
    my ( $handle, $fatal, $message ) = @_;
    $handle-&gt;destroy;
    undef $handle;
    say STDERR &quot;$fatal : $message\n&quot;;
},
on_read =&gt; sub {
    my $printer_handle = shift;
    $handle-&gt;push_read(
        line =&gt; sub {
            my ( $printer_handle, $line ) = @_;
            say sprintf( &quot;Reply: [%s]&quot;, $line );
        }
    );
}
);

# Отправляем команду принтеру
$port-&gt;write(&quot;M105\n&quot;);

$cv-&gt;recv;
</code></pre>

<p>После запуска (если все параметры указаны верно) получим такой вывод:</p>

<pre><code>Connecting.. [/dev/ttyUSB0] [115200]
Reply: [ok T:26.6 /0.0 @:0]
</code></pre>

<p>Подключение к принтеру и передача данных в обе стороны прошли успешно!</p>

<p><strong>Важный нюанс!</strong></p>

<p>Хэндлер порта полученный тут <code>my $fh = $port-&gt;{&#39;HANDLE&#39;};</code> <strong>однонаправленный на чтение</strong>! Если попытаться туда что-то записать силами AE то получим ошибку. Писать надо напрямую в объект порта, что и происходит в предпоследней строке.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/anyevent/">AnyEvent</a>
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/serial-port/">serial port</a>
                    <a href="http://alpha6.ru/blog/tag/hardware/">hardware</a>
                </p>

        ]]></content>
        <updated>2017-05-28T00:00:00Z</updated>
        <category term="AnyEvent" />
        <category term="perl" />
        <category term="serial port" />
        <category term="hardware" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/09/08/send-html-email-with-perl/</id>
        <title>Отправляем емейл из Perl с авторизацией и html</title>
        <link href="http://alpha6.ru/blog/2016/09/08/send-html-email-with-perl/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Отправляем письмо в html с авторизацией из Perl.</p>

<pre><code>use strict;
use Net::SMTP;
use Authen::SASL; #нужен для авторизации

use utf8;
use Encode;
use MIME::Base64


  my $message = &quot;&lt;html&gt;&lt;body&gt;Тестовое письмо&lt;/body&gt;&lt;/html&gt;&quot;;

# авторизационные данные
my $smtp_host = &#39;smtp.server.address&#39;;
my $smtp_user = &#39;user_name&#39;;
my $smtp_pass = &#39;password&#39;;


my $debug = 1; # рассматриваем процесс подключения в деталях

# mail properties
my $mail_from = &#39;user@example.com&#39;;
my $mail_to = &#39;recipient@example.com&#39;;
my $mail_subject = &#39;Тестовое письмо&#39;;

# Выставляем заголовки. Сюда можно добавить еще всякого при необходимости
my $mail_headers = &quot;From: $mail_from\n&quot;.
&quot;To: $mail_to\n&quot;.
&quot;Subject: &quot;.encode(&#39;MIME-Header&#39;,$mail_subject).&quot;\n&quot;.
&quot;MIME-Version: 1.0\n&quot;.
&quot;Content-type: text/html; charset=UTF-8\n&quot;.
&quot;Content-Transfer-Encoding: base64\n\n&quot;;

my $mail_body = $message;

# Отправляем письмо
my $smtp = Net::SMTP-&gt;new($smtp_host, Debug =&gt; $debug) or die &quot;cannot connect to server&quot;;
$smtp-&gt;auth($smtp_user,$smtp_pass) or die &quot;could not authenticate&quot;;
$smtp-&gt;mail($mail_from);
$smtp-&gt;to($mail_to);
$smtp-&gt;data();
$smtp-&gt;datasend($mail_headers);
$smtp-&gt;datasend(encode_base64(encode(&#39;UTF-8&#39;, $mail_body)));
$smtp-&gt;dataend();
$smtp-&gt;quit;
</code></pre>

<p>При необходимости можно добавить файлы, PGP подписи и так далее.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/net-smtp/">net::smtp</a>
                    <a href="http://alpha6.ru/blog/tag/email/">email</a>
                </p>

        ]]></content>
        <updated>2016-09-08T00:00:00Z</updated>
        <category term="perl" />
        <category term="net::smtp" />
        <category term="email" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/</id>
        <title>State переменные в Perl</title>
        <link href="http://alpha6.ru/blog/2015/12/26/state-variabes-in-perl/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>В Perl существует особый тип переменных под названием state.</p>

<p>В <a href="http://perldoc.perl.org/functions/state.html">доке</a> про них написано:</p>

<blockquote>
  <p>state declares a lexically scoped variable, just like my. However, those variables will never be reinitialized ...</p>
</blockquote>

<p>На первый взгляд это дает нам возможность очень просто реализовывать счетчики и иже с ними:</p>

<pre><code>sub count {
  state $count = 0;
  $count++;
}
</code></pre>

<p>Однако, есть нюанс - фраза <em>will never be reinitialized</em> означает что переменная действительно никогда не будет переинициализирована пока существует родительский скрипт. И это дает нам вот такую замечательную граблю на которую можно ненароком наступить:</p>

<p>Объявляем пакет:</p>

<pre><code>package MyTestState;

use strict;
use feature &#39;state&#39;;

sub new {
  bless {}, shift;
}

sub count {
  state $count = 0;
  $count++;
}

1;
</code></pre>

<p>И саму программу:</p>

<pre><code>use lib &#39;lib&#39;;
use v5.18;
use MyTestState;

my $mystate =  MyTestState-&gt;new();

for (0..10) {
  my $counter = $mystate-&gt;count();
  say &quot;Counter [$counter]&quot;;
}
</code></pre>

<p>Вывод ожидаем:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
</code></pre>

<p>А теперь добавляем такой код:</p>

<pre><code>undef $mystate;

say &quot;next object!=======&quot;;

my $mystate1 = MyTestState-&gt;new();
for (0..10) {
  my $counter = $mystate1-&gt;count();
  say &quot;Counter [$counter]&quot;;

}
</code></pre>

<p>Здесь мы удаляем старый объект со счетчиком и создаем новый. Логично предположить что счетчик пойдет заново, но на самом деле нет. Не смотря на то что мы удалили старый объект и создали новый, переменная со счетчиком никуда не делась и не была переиницализирована! И при запуске программы мы увидим:</p>

<pre><code>Counter [0]
Counter [1]
Counter [2]
...
Counter [10]
next object!
Counter [11]
Counter [12]
Counter [13]
...
Counter [20]
Counter [21]
</code></pre>

<p>Так что слово <code>newer</code> в документации действительно значит &quot;никогда пока жив инстанс интерпретатора запустивший скрипт&quot;.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/state/">state</a>
                    <a href="http://alpha6.ru/blog/tag/trap/">trap</a>
                </p>

        ]]></content>
        <updated>2015-12-26T00:00:00Z</updated>
        <category term="perl" />
        <category term="state" />
        <category term="trap" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2015/09/19/dbd-pg-install/</id>
        <title>DBD::Pg install</title>
        <link href="http://alpha6.ru/blog/2015/09/19/dbd-pg-install/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Markdown content goes here.</p>

<p>Если при установке <code>DBD::Pg</code> через <code>CPAN</code> у вас начинают спрашивать какие-то странные слова про номер версии и расположение директорий Postgresql - проверьте что у вас установлен пакет <code>postgresql-server-dev-X.X</code> (<code>postgresql-server-dev-all</code>).</p>

<p>После его установки проблема магическим (на самом деле нет) образом исчезает.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/ubuntu/">ubuntu</a>
                    <a href="http://alpha6.ru/blog/tag/postgresql/">postgresql</a>
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/dbd-pg/">dbd::pg</a>
                </p>

        ]]></content>
        <updated>2015-09-19T00:00:00Z</updated>
        <category term="ubuntu" />
        <category term="postgresql" />
        <category term="perl" />
        <category term="dbd::pg" />
    </entry>
</feed>

