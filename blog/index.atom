<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alpha6.ru/blog/</id>
    <title>Just another blog</title>
    <updated>2017-07-04T00:00:00Z</updated>
    <link href="http://alpha6.ru/blog/index.atom" rel="self" />
    <link href="http://alpha6.ru/blog/" rel="alternate" />
    <generator version="0.083">Statocles</generator>

    <entry>
        <id>http://alpha6.ru/blog/2017/07/04/installing-convos/</id>
        <title>Installing Convos</title>
        <link href="http://alpha6.ru/blog/2017/07/04/installing-convos/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Современные технологии это всегда хорошо, но и нестареющая классика на то и классика чтобы про нее не забывать. В данном случае я говорю об IRC.
IRC прекрасная технология, вот только мобильные клиенты для него отличаются кривостью и нестабильностью работы. А уж зайти в IRC из корпоративных сетей может быть еще тем квестом.
Плюс особенностью IRC является тот факт, что никакой истории сообщений там не хранится и все что было в ваше отсутствие на канале пройдет мимо вас.
Частично решить первую проблему и полностью вторую и третью предназначен Convos.</p>

<p>Это веб интерфейс для IRC. Умеет поддерживать много соединений. Хранит историю и дает приятный веб-интерфейс неплохо работающий на смартфонах.</p>

<p>Будем ставить его из гита на свой сервер. Для таких целей я использую OpenVZ сервера от <a href="https://billing.time4vps.eu/?affid=1845">Time4vps</a>. Серваки в Европе, стоят дешево, работают достаточно шустро и стабильно. Для наших целей достаточно самого дешевого.</p>

<p>Считаем что сервер у нас есть и даже с доменным именем.</p>

<p>Настроим SSL, нам он нужен только для того что-бы наш трафик не читал кто попало, так что хватит сертификата от LetsEncript. Тем более что получение и обновление сертификата нынче автоматизировано во всех более-менее современных дистрибутивах.</p>

<h1>Настраиваем nginx и SSL</h1>

<p>Устанавливаем certbot:</p>

<pre><code>apt-get install certbot
</code></pre>

<p>Зарегистрируемся в сервисе (надо сделать один раз):</p>

<pre><code>certbot register --email me@example.com
</code></pre>

<p>Настроим nginx для поддержки автоматического обновления сертификатов:</p>

<pre><code>mkdir -p /var/www/html/.well-known/acme-challenge
echo Success &gt; /var/www/html/.well-known/acme-challenge/example.html
</code></pre>

<p>Создадим инклюд для нашего локейшена для обновления сертификатов:</p>

<pre><code>vim /etc/nginx/acme

location /.well-known {
    root /var/www/html;
}
</code></pre>

<p>Заворачиваем все запросы (кроме обновления сертификатов) на https:</p>

<pre><code>vim /etc/nginx/sites-aviable/default

server {
    listen 80 default_server;

    include acme;

    location / {
        return 301 https://$host$request_uri;
    }
}
</code></pre>

<p>Перезагружаем nginx и проверяем что локейшен доступен:</p>

<pre><code>service nginx reload

curl -L http://irc.alpha6.ru/.well-known/acme-challenge/example.html
Success
</code></pre>

<p>Удаляем файл который мы создали для теста:</p>

<pre><code>rm http://irc.alpha6.ru/.well-known/acme-challenge/example.html
</code></pre>

<p>В принципе он ни на что не влияет, но с ним certbot будет ругаться что не удалось удалить все лишнее после обновления сертификатов.</p>

<p>Создаем конфиг файл для certbot, чтобы не задавал лишних вопросов и работал автоматом:</p>

<pre><code>vim /etc/letsencrypt/cli.ini

authenticator = webroot
webroot-path = /var/www/html
post-hook = service nginx reload
text = True
agree-tos = True
email = imdefined@yandex.ru
</code></pre>

<p>Проверяем что все работает как надо:</p>

<pre><code>certbot certonly --dry-run -d irc.alpha6.ru

Saving debug log to /var/log/letsencrypt/letsencrypt.log
Starting new HTTPS connection (1): acme-staging.api.letsencrypt.org
Cert not due for renewal, but simulating renewal for dry run
Renewing an existing certificate
Performing the following challenges:
http-01 challenge for irc.alpha6.ru
Using the webroot path /var/www/html for all unmatched domains.
Waiting for verification...
Cleaning up challenges
Unable to clean up challenge directory /var/www/html/.well-known/acme-challenge
Generating key (2048 bits): /etc/letsencrypt/keys/0004_key-certbot.pem
Creating CSR: /etc/letsencrypt/csr/0004_csr-certbot.pem
Running post-hook command: service nginx reload

IMPORTANT NOTES:
- The dry run was successful.
- If you lose your account credentials, you can recover through
e-mails sent to imdefined@yandex.ru.
- Your account credentials have been saved in your Certbot
configuration directory at /etc/letsencrypt. You should make a
secure backup of this folder now. This configuration directory will
also contain certificates and private keys obtained by Certbot so
making regular backups of this folder is ideal.
</code></pre>

<p>Все ок, получаем полноценный сертификат:</p>

<pre><code>certbot certonly -d irc.alpha6.ru

Saving debug log to /var/log/letsencrypt/letsencrypt.log
Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
Obtaining a new certificate
Performing the following challenges:
http-01 challenge for irc.example.com
Using the webroot path /var/www/html for all unmatched domains.
Waiting for verification...
Cleaning up challenges
Generating key (2048 bits): /etc/letsencrypt/keys/0004_key-certbot.pem
Creating CSR: /etc/letsencrypt/csr/0004_csr-certbot.pem

IMPORTANT NOTES:
    - Congratulations! Your certificate and chain have been saved at
    /etc/letsencrypt/live/irc.example.com/fullchain.pem. Your cert will
    expire on 2017-10-09. To obtain a new or tweaked version of this
    certificate in the future, simply run certbot again. To
    non-interactively renew *all* of your certificates, run &quot;certbot
    renew&quot;
</code></pre>

<p>Теперь создадим конфиг nginx для сервиса:</p>

<pre><code>vim /etc/nginx/sites-available/irc.example.com

server {
    listen 443 ssl;

    ssl on;
    ssl_stapling on;

    server_name irc.alpha6.ru;

    ssl_certificate     /etc/letsencrypt/live/irc.alpha6.ru/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/irc.alpha6.ru/privkey.pem;

    ssl_ciphers &#39;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&#39;;
    ssl_prefer_server_ciphers on;

    ssl_dhparam /etc/nginx/conf.d/dhparams.pem;

    error_log  /var/log/nginx/irc.alpha6.ru.error.log error;


    include acme;

    location / {
        proxy_pass      http://127.0.0.1:3001;
        access_log     /var/log/nginx/irc.alpha6.ru.log combined;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;

        # Enable Convos to construct correct URLs by passing on custom
        # headers. X-Request-Base is only required if &quot;location&quot; above
        # is not &quot;/&quot;.
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

    }

}
</code></pre>

<p>Активируем этот сайт:</p>

<pre><code>ln -s /etc/nginx/sites-available/irc.example.com /etc/nginx/sites-enabled/
</code></pre>

<p>Сгенерим усиленные параметры шифрования для DHE:</p>

<pre><code>openssl dhparam -out /etc/ssl/private/dhparam.pem 2048
</code></pre>

<p>Добавим их в конфигурацию nginx:</p>

<pre><code>vim /etc/nginx/conf.d/ssl_parameters.conf

ssl_dhparam /etc/ssl/private/dhparams.pem;
</code></pre>

<p>Перезапускаем nginx и наслаждаемся ошибкой 502 по тому адресу где должен быть сайт :)</p>

<pre><code>service nginx restart
</code></pre>

<h1>Настроим firewall</h1>

<p>Создадим system.d сервис который будет поднимать firewall при старте сети:</p>

<pre><code>vim /etc/systemd/system/firewall.service

[Unit]
Description=Add Firewall Rules to iptables

[Service]
Type=oneshot
ExecStart=/etc/firewall/enable.sh

[Install]
WantedBy=multi-user.target
</code></pre>

<p>Firewall я тут привожу самый простой, блокирует доступ ко всем портам кроме 22, 80, 443 и всех выпускает наружу:</p>

<pre><code>vim /etc/firewall/enable.sh

#!/bin/sh

# iptables script generated 2017-07-04
# http://www.mista.nu/iptables

IPT=&quot;/sbin/iptables&quot;

# Flush old rules, old custom tables
$IPT --flush
$IPT --delete-chain

# Set default policies for all three default chains
$IPT -P INPUT DROP
$IPT -P FORWARD DROP
$IPT -P OUTPUT ACCEPT

# Enable free use of loopback interfaces
$IPT -A INPUT -i lo -j ACCEPT
$IPT -A OUTPUT -o lo -j ACCEPT

# All TCP sessions should begin with SYN
$IPT -A INPUT -p tcp ! --syn -m state --state NEW -s 0.0.0.0/0 -j DROP

# Accept inbound TCP packets
$IPT -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPT -A INPUT -p tcp --dport 22 -m state --state NEW -s 0.0.0.0/0 -j ACCEPT
$IPT -A INPUT -p tcp --dport 80 -m state --state NEW -s 0.0.0.0/0 -j ACCEPT
$IPT -A INPUT -p tcp --dport 443 -m state --state NEW -s 0.0.0.0/0 -j ACCEPT
</code></pre>

<h1>Поднимаем сервис Convos</h1>

<p>Создадим пользователя convos. От его имени будет работать сервис.</p>

<p>Устанавливаем <a href="https://perlbrew.pl">perlbrew</a> (Этот шаг можно пропустить если у вас относительно свежий дистрибутив, но я предпочитаю контролировать среду где у меня работает софт).
Perlbrew ставим от root в систему чтобы он был виден все пользователям:</p>

<pre><code>apt-get install perlbrew
perlbrew init
source /opt/perlbrew/etc/bashrc

echo source /opt/perlbrew/etc/bashrc &gt;&gt; /etc/bash.bashrc
</code></pre>

<p>Устанавливаем perl 5.24.1 и переключаемся на него чтобы поставить пару модулей (на момент написания статьи Convos не ставился на 5.26 из-за ошибки в одном из сторонних модулей).</p>

<pre><code>perlbrew install perl-5.24.1
perlbrew use perl-5.24.1
cpan -i Carton
</code></pre>

<p>После установки perl и Carton можно настраивать все дальше.</p>

<p>Для начала создадим system.d сервис который будет поднимать наш сервис после старта nginx (потому что если nginx не поднялся все равно ничего работать не будет).</p>

<pre><code>vim /etc/systemd/system/convos.service

[Unit]
After=nginx.service
Description=ConvosService

[Service]
ExecStart=/srv/convos/start.sh
WorkingDirectory=/srv/convos
User=convos
Group=convos
Restart=always

[Install]
WantedBy=default.target
</code></pre>

<p>Клонируем convos из гита в /srv/convos</p>

<pre><code>cd /srv/
git clone https://github.com/Nordaaker/convos.git
</code></pre>

<p>Переключаемся на пользователя convos и ставим все зависимости через Carton:</p>

<pre><code>su convos
cd /srv/convos 
export PERLBREW_ROOT=/opt/perlbrew
export PERLBREW_HOME=/srv/convos/.perlbrew_convos
source ${PERLBREW_ROOT}/etc/bashrc

carton install
</code></pre>

<p>После того как поставятся все зависимости создадим враппер для запуска сервиса Convos</p>

<pre><code>vim /srv/convos/start.sh 
#!/bin/bash

## These 3 lines are mandatory.
export PERLBREW_ROOT=/opt/perlbrew
export PERLBREW_HOME=/srv/convos/.perlbrew_convos
source ${PERLBREW_ROOT}/etc/bashrc

## Do stuff with 5.24.1
perlbrew use 5.24.1
export MOJO_REVERSE_PROXY=1
#export CONVOS_DEBUG=1
carton exec ./script/convos daemon --listen http://127.0.0.1:3001
</code></pre>

<p>Активируем сервис system.d и проверяем его статус: </p>

<pre><code>systemctl enable convos
systemctl -l status convos
</code></pre>

<p>Для начала лучше запустить враппер руками от пользователя convos и убедится что нет ошибок запуска (заодно посмотреть инвайт код для регистрации через веб).</p>

<p>Если все в порядке - то запускаем сервис через system.d и наслаждаемся прогрессивной работой в IRC. </p>

<p>Если сервис таки не запустился, то посмотреть ошибки можно командой:</p>

<pre><code>journalctl -u convos -f
</code></pre>

<h2>Make the IRC great again!</h2>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/convos/">convos</a>
                    <a href="http://alpha6.ru/blog/tag/irc/">irc</a>
                </p>

        ]]></content>
        <updated>2017-07-04T00:00:00Z</updated>
        <category term="perl" />
        <category term="convos" />
        <category term="irc" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2017/05/28/async-serial-port/</id>
        <title>Асинхронная работа с COM-портом в Perl</title>
        <link href="http://alpha6.ru/blog/2017/05/28/async-serial-port/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Понадобилось мне тут поработать с 3d принтером из Perl. Принтер подключается к компьютеру через USB-COM переходник и прикидывается обычным COM портом со всеми вытекающими способами работы.</p>

<p>Для работы с ком-портом в Perl есть отличный модуль - <a href="https://metacpan.org/pod/Device::SerialPort">Device::SerialPort</a>. А для асинхронности используем классический AnyEvent. Ну и долго сказка сказывается, да быстро код пишется - пример кода:</p>

<pre><code>#!/usr/bin/env perl

use v5.20;
use strict;

use AnyEvent;
use AnyEvent::Handle;

use Device::SerialPort;

my $cv = AE::cv;

# Базовые параметры подключения к порту
my $device_port = &#39;/dev/ttyUSB0&#39;;
my $port_speed  = 115200;

say &quot;Connecting.. [$device_port] [$port_speed]&quot;;
my $port = Device::SerialPort-&gt;new($device_port);
$port-&gt;baudrate($port_speed); #Устанавливаем скорость соединения

# Чуть более продвинутые настройки
$port-&gt;handshake(&quot;none&quot;); #Не используем handshake иначе подключение будет устанавливаться только в момент перезагрузки принтера

# Режим коммуникации 8N1
$port-&gt;databits(8);
$port-&gt;parity(&quot;none&quot;);
$port-&gt;stopbits(1);

$port-&gt;stty_echo(0); # Выключаем эхо
$port-&gt;error_msg(&#39;ON&#39;); # Включаем выдачу ошибок от порта

# Получаем чистый хэндлер порта и с ним создаем объект AE::Handle
my $fh = $port-&gt;{&#39;HANDLE&#39;};

my $handle;
$handle = AnyEvent::Handle-&gt;new(
fh       =&gt; $fh,
on_error =&gt; sub {
    my ( $handle, $fatal, $message ) = @_;
    $handle-&gt;destroy;
    undef $handle;
    say STDERR &quot;$fatal : $message\n&quot;;
},
on_read =&gt; sub {
    my $printer_handle = shift;
    $handle-&gt;push_read(
        line =&gt; sub {
            my ( $printer_handle, $line ) = @_;
            say sprintf( &quot;Reply: [%s]&quot;, $line );
        }
    );
}
);

# Отправляем команду принтеру
$port-&gt;write(&quot;M105\n&quot;);

$cv-&gt;recv;
</code></pre>

<p>После запуска (если все параметры указаны верно) получим такой вывод:</p>

<pre><code>Connecting.. [/dev/ttyUSB0] [115200]
Reply: [ok T:26.6 /0.0 @:0]
</code></pre>

<p>Подключение к принтеру и передача данных в обе стороны прошли успешно!</p>

<p><strong>Важный нюанс!</strong></p>

<p>Хэндлер порта полученный тут <code>my $fh = $port-&gt;{&#39;HANDLE&#39;};</code> <strong>однонаправленный на чтение</strong>! Если попытаться туда что-то записать силами AE то получим ошибку. Писать надо напрямую в объект порта, что и происходит в предпоследней строке.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/anyevent/">AnyEvent</a>
                    <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                    <a href="http://alpha6.ru/blog/tag/serial-port/">serial port</a>
                    <a href="http://alpha6.ru/blog/tag/hardware/">hardware</a>
                </p>

        ]]></content>
        <updated>2017-05-28T00:00:00Z</updated>
        <category term="AnyEvent" />
        <category term="perl" />
        <category term="serial port" />
        <category term="hardware" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2017/02/09/rostock-autolevel/</id>
        <title>Автоматическая калибровка на датчике веса на примере Rostock mini</title>
        <link href="http://alpha6.ru/blog/2017/02/09/rostock-autolevel/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Во всех моих 3д-принтерах меня каждый раз неимоверно бесила необходимость выставлять высоту сопла над уровнем стола. Необходимость эта возникала регулярно, при каждой замене сопла или каких-то других действиях с хотэндом, требовавших его разборки.</p>

<p>Периодически я видел всякие конструкции на базе датчиков приближения (холла), оптических датчиков и прочих шайтан-машин. Но все они требовали точно так же выставлять уровень сопла после каких-либо манипуляций с хотом. Правда, теперь уровень задавался относительно датчика, а не стола. Но радости это все равно не приносило.</p>

<p>Проблему решать надо было кардинально. Для этого нужно, чтобы в качестве датчика уровня использовалось само сопло.</p>

<p>Первое и самое очевидное решение - кинуть один провод на хот, второй на стол, и все это дело завсести на пины концевика. Надежное и дешевое решение, если у вас стол из алюминия без покрытия. У меня на столе лежит зеркало, и такой способ мне не подходит.</p>

<p>Второй способ был - поставить микрик на каретку так, чтобы касание соплом стола вызывало срабатывание микрика. Способ рабочий, но у меня не получилось избавиться от люфтов в креплении хот-энда, и я от него отказался.</p>

<p>Затем на просторах ютуба я увидел, как работает автоматическая калибровка на датчике веса. Правда, там пленочные датчики крепились на стол, но быстрый поиск по запасникам алиэкспресса выдал металлические датчики в виде брусков, на которые уже можно повесить хот-энд.</p>

<p>Я заказал <a href="http://alipromo.com/redirect/cpa/o/ol4k5ubfoept22yoak4cceyn43ykeuok/">модуль АЦП HX711</a> и сам <a href="http://alipromo.com/redirect/cpa/o/ol4k7ueyxqvue32fhvhmfy8n830yd08f/">датчик на 1кг</a>. Спустя месяц ожидания все это дело было получено и настало время прикрутить эту красоту к принтеру.</p>

<p>Есть два варианта подключения. Первый - это подключить АЦП напрямую к мозгам принтера и сказать прошивке, что это датчик веса. Но это решение, на мой взгляд, сильно так себе. Во-первых, поддержка таких датчиков находится пока только в экспериментальном состоянии. Во-вторых, мозгам и так есть чем заняться помимо того, чтобы постоянно читать вес от датчика и пытаться понять, что там происходит.
Значит нам нужен второй вариант: подключить это через промежуточный контроллер, который будет прикидываться концевиком для мозгов принтера. Его и выберем.</p>

<p>План действий будет следующий:</p>

<ul>
<li>Печатаем крепления датчика на эффектор</li>
<li>Подключаем датчик веса к Arduino</li>
<li>Подключаем Arduino с датчиком к мозгам принтера</li>
<li>Редактируем прошивку принтера.</li>
</ul>

<p>Крепления можно скачать <a href="http://www.thingiverse.com/thing:2102961">тут</a>. Вариант сыроватый, но рабочий и дорабатываемый по мере выявления недостатков.</p>

<p>Теперь подключаем контроллер к АЦП. Я нарыл в закромах Arduino Nano, но это не принципиально. На время отладки и калибровки сойдет и так, а дальше я поменяю на Attiny13, которая будет монтироваться вместе с платой АЦП прямо на эффектор для уменьшения уровня наводок по всем этим трактам. Почему на эффектор, а не рядом с основными мозгами принтера? Потому что для наилучшей точности стоит максимально укоротить провода между АЦП и датчиком веса. А если мы монтируем туда АЦП, то есть смысл прицепить туда и контроллер, чтобы от эффектора просто вести три провода к мозгам.</p>

<p>Также с этим АЦП есть нюанс: по умолчанию частота выборок АЦП составляет 10Гц, что слишком мало для нашего применения. То есть, технически, будет работать и так, но точность срабатывания будет плохой.
Для нормальной работы надо перевести АЦП в режим частоты опроса 80Гц. Для этого надо отцепить ногу <code>RATE</code> от земли и посадить ее на VCC.
<img alt="HX711 schema" src="http://alpha6.ru/static/img/hx711/HX711-schema.jpg"></p>

<p>Тут есть два варианта, зависят от ревизии платы HX711.</p>

<p>Вариант с новой ревизией - просто запаиваем перемычку на слева от которой написано 80Hz.
<img alt="HX711 new" src="http://alpha6.ru/static/img/hx711/HX711-2.jpg"></p>

<p>Если не повезло и пришла старая ревизия, то надо отпаять от платы вторую сверху ногу со стороны 4х-пинового разъема и подпаять ее к VCC или первой сверху ноге.
 <img alt="HX711 old" src="http://alpha6.ru/static/img/hx711/HX711-1.jpg"></p>

<p>Все, модуль переключен в режим опроса 80Гц и наша жизнь стала немного прекраснее.</p>

<p>Зачем это проделывать? Так как показания датчика нестабильны из-за наличия вентилятора на голове и постоянных движений эффектора в процессе калибровки, то в скетче используется фильтр НЧ, который сглаживает скачки показаний датчика для большей надежности работы. Фильтр берет 10 значений веса и из них получает отфильтрованные показания. На частоте 80Гц выборка 10 значений занимает примерно 120мс, на частоте 10Гц - займет секунду. Соответственно, надо жертвовать фильтром, что будет приводить к ложным срабатываниям во время движения головы.</p>

<p>Подключаем датчик к АЦП. Соединяем провода:</p>

<ul>
<li>Красный -&gt; E+</li>
<li>Черный  -&gt; E-</li>
<li>Белый   -&gt; A-</li>
<li>Зеленый -&gt; A+</li>
</ul>

<p>Подключаем АЦП к Arduino:</p>

<ul>
<li>VCC -&gt; 5V Arduino</li>
<li>DT  -&gt; A2</li>
<li>CLK -&gt; A3</li>
<li>GND -&gt; GND Arduino</li>
</ul>

<p>Клонируем репозиторий</p>

<pre><code>git clone https://github.com/alpha6/HX711_endstop
</code></pre>

<p>и открываем в Arduino IDE скетч - <em>Tenso_sensor.ino</em></p>

<p>В скетче меняем <code>const bool DEBUG = false;</code> на <code>const bool DEBUG = true;</code></p>

<p>Заливаем скетч в Arduino и через Serial monitor смотрим за показаниями.</p>

<p>2 раза в секунду там должна появляться строка</p>

<pre><code>current weight! [848342] [848267]
</code></pre>

<p>цифры будут зависеть от нагрузки на датчик и погоды на Юпитере и могут плавать между измерениями, даже если датчик просто лежит на столе.</p>

<p>Убеждаемся, что значения датчика меняются при воздействии на него. Если меняются, значит, все собрано верно. Если нет - надо поменять местами провода DT и CLK. Я так один раз перепутал контакты DT и CLK: с виду все работало, но при попытке калибровки принтер попытался проломить соплом стол.</p>

<p><strong>В установленном на принтер виде цифра от датчика должна увеличиваться при касании стола!</strong></p>

<p>Теперь сделаем из Arduino концевик для мозгов принтера.</p>

<p>Для управления принтером у меня используется плата Melzi. Для RAMPS все будет сильно проще с точки зрения получения пинов и настройки прошивки.</p>

<p>Для этого нам понадобится любой оптрон и резистор на 1кОм. Оптрон я использовал 4n35, потому что он был под рукой. Любой другой подключается аналогично с разницей на нумерацию ног.</p>

<p>На плате Melzi всего 3 пина под концевики, на Дельте они все используются для калибровки осей. Так что нам нужен какой-то другой концевик. На своем принтере я не использую экран с кнопками, и у меня есть целый свободный разъем на 10 пин рядом с ISP, так что я буду использовать пин A1 оттуда. Для RAMPS никаких подобных телодвижений не надо, благо, концевиков у него хватает.</p>

<ul>
<li>Соединяем землю Arduino и пин 2 оптрона</li>
<li>Сажаем пин 1 через резистор на пин D7</li>
<li>Пин 4 оптрона соединяем с землей 10 пинового разъема на Melzi. Для RAMPS соединяем с землей концевика Z-Min</li>
<li>Пин 5 отпрона соединяем с пином A1 10 пинового разъема на Melzi. Для RAMPS соединяем с сигнальным пином концевика Z-Min.</li>
</ul>

<p>Схема подключения:</p>

<p><img alt="4n35" src="http://alpha6.ru/static/img/hx711/4n35.png"></p>

<p>Устанавливаем датчик на принтер. После того, как все установлено, подводим датчик к столу. Задача - откалибровать порог срабатывания так, чтобы датчик срабатывал от касания стола, но не срабатывал от движений головы.</p>

<p>Для контроля срабатываний без заглядывания в сериал-монитор удобно подключить светодиод. Цепляем землю диода на пин 5 оптрона, а + через резистор на +5В. Теперь диод будет загораться при срабатывании датчика.</p>

<p>Теперь отредактируем прошивку.</p>

<p>Я не буду описывать конфигурацию прошивки с нуля, опишу только специфичные для калибровки вещи. По всему остальному в интернете полно гайдов, а эта статья и так здоровенная выходит.
Предполагается, что все остальное уже настроено для Дельты, принтер работает и нужно только автокалибровку прикрутить.</p>

<p>Будем использовать самые последние решения в стане прошивкостроения.</p>

<p>Клонируем репозиторий Marlin</p>

<pre><code>git clone https://github.com/MarlinFirmware/Marlin.git
</code></pre>

<p>Переключаемся на бранч RcBugFix потому что в master и RC автокалибровка на дельтах не работает.</p>

<pre><code>cd Marlin
git checkout -b RcBugFix
</code></pre>

<p>Открываем прошивку в Arduino IDE. Настраиваем все, что необходимо, и приступаем к настройке автокалибровки.
Первым делом нам надо добавить концевик Z-Min для Melzi. На RAMPS он есть, и этот пункт нужно пропустить.</p>

<p><em>N.B.</em> Если у вас вообще не Дельта с хомингом в Z-MIN, то просто воткните Arduino в Z_MIN и смело пропускайте все настройки высот и прочее, что относится к дельтам или принтерам с хомингом стола в Z_MAX.</p>

<p>Открываем вкладку <code>pins_SANGUINOLOLU_11.h</code> и после</p>

<pre><code>#define E0_DIR_PIN          0
</code></pre>

<p>добавляем строки</p>

<pre><code>#define Z_MIN_PROBE_PIN     30
#define Z_MIN_PIN           30
</code></pre>

<p>Технически, должно хватить только указания Z_MIN_PIN, но в той ревизии, что сейчас лежит в гите, есть баг, и сборка падает, если не задан Z_MIN_PROBE_PIN.</p>

<p>Сохраняем файл и переходим в <code>Configuration.h</code></p>

<p>Раскомментируем строку</p>

<pre><code>#define USE_ZMIN_PLUG
</code></pre>

<p>В строке</p>

<pre><code>#define Z_MIN_PROBE_ENDSTOP_INVERTING false
</code></pre>

<p><code>false</code> меняем на <code>true</code></p>

<p>Раскомментируем строку</p>

<pre><code>#define FIX_MOUNTED_PROBE
</code></pre>

<p>Выставим смещения Z-Probe на 0</p>

<pre><code>#define Y_PROBE_OFFSET_FROM_EXTRUDER 0   // Y offset: -front +behind [the nozzle]
#define Z_PROBE_OFFSET_FROM_EXTRUDER 0
</code></pre>

<p>Раскомментируем строку</p>

<pre><code>#define Z_MIN_PROBE_ENDSTOP
</code></pre>

<p>Ну, и главная наша цель:</p>

<pre><code>#define AUTO_BED_LEVELING_FEATURE
</code></pre>

<p>Тоже раскомментируем. Также раскомментируем строку</p>

<pre><code>#define AUTO_BED_LEVELING_BILINEAR
</code></pre>

<p>Это единственный доступный тип автоуровня для Дельты. Сопло проходит по всему столу и строит квадратную карту высот, по которой потом печатает.
В строке:</p>

<pre><code>#define ABL_GRID_MAX_POINTS_X 3
</code></pre>

<p>регулируется кол-во точек на грани квадрата. Т.е., при настройке в 3 сопло проверит высоту в 9 точках. Если указать 9 - то точек будет 81, время калибровки возрастет соответственно.</p>

<p>Также стоит выставить высоту области печати в значение, близкое к реальному.</p>

<pre><code>#define MANUAL_Z_HOME_POS 156.8
</code></pre>

<p>Сопло после выполнения <code>G28</code> и получения <code>G29</code> идет в минимум со скоростью, указанной для хоминга. Скорость эта по умолчанию составляет 2000 мм/мин, на некотором расстоянии от поверхности стола скорость сбрасывается в 2 раза и на этой скорости происходит касание. Если заданная в прошивке высота области печати будет сильно больше реальной, то сопло просто врежется на полном ходу в стол и датчик может не успеть сработать. Точнее, датчику на срабатывание надо 120мс, за это время сопло пройдет 4мм вниз. А дальше все зависит от прочности конструкции и силы моторов. Один раз таким образом у меня получилось разбить стекло на столе.</p>

<p>А если область печати будет меньше реальной, то от заданной области печати сопло будет идти со скоростью в 2 раза меньше скорости калибровки, и ждать окончания процесса придется очень долго.</p>

<p>Скорости хоминга по Z регулирются этими строками:</p>

<pre><code>#define Z_PROBE_SPEED_FAST HOMING_FEEDRATE_Z
#define Z_PROBE_SPEED_SLOW (Z_PROBE_SPEED_FAST / 2)
</code></pre>

<p>Еще можно включить опцию двойного касания, дает большую точность (в теории), но и занимает больше времени:</p>

<pre><code>#define PROBE_DOUBLE_TOUCH
</code></pre>

<p>Заливаем прошивку в принтер. Проверяем, что работает <code>G28</code>, командой M119 проверяем, что концевик <code>Z-MIN</code> в состоянии <code>open</code>.</p>

<p>Теперь откалибруем датчик веса на нужный уровень срабатывания.</p>

<p>Для этого подводим голову к поверхности стола и прижимаем сопло к столу. В этот момент должен сработать датчик. Если этого не произошло, уменьшаем порог срабатывания:</p>

<pre><code>long trigger = 13000;
</code></pre>

<p>Имеет смысл уменьшать сразу на 1000, но это зависит от используемого датчика. У меня датчик срабатывает от легкого касания сопла пальцем. Чемь меньше будет порог срабатывания, тем лучше, но без фанатизма. Он не должен срабатывать от торможения каретки при калибровке, например.</p>

<p>Датчик работает. В качестве финального штриха к портрету, проверяем, что в разных положения эффектора в области печати не срабатывает датчик из-за натяжения трубки боудена или проводов вентилятора. Пишу этот пункт по собственному опыту, ибо я долго боролся со срабатыванием датчика при торможении каретки, а оказалось, что это трубка боудена дергала хот вверх со всеми вытекающими. После изменения положения мотора экструдера проблема ушла.</p>

<p>Теперь, когда все проверено, говорим G29. Голова поедет вниз и начнет тыкаться в стол согласно количеству точек, указанных в прошивке. После окончания калибровки будет выдана карта высот. Стоит убедиться, что все значения в ней находятся на одном уровне в переделах погрешности (второй цифры после запятой). Ну, это если стол ровный, без бугров, впадин и перекосов.</p>

<p>Все. На этом процесс настройки автокалибровки завершен, и можно заняться ее тюнигом.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/3d-printer/">3d-printer</a>
                    <a href="http://alpha6.ru/blog/tag/melzi/">melzi</a>
                    <a href="http://alpha6.ru/blog/tag/marlin/">marlin</a>
                    <a href="http://alpha6.ru/blog/tag/rostock/">rostock</a>
                    <a href="http://alpha6.ru/blog/tag/autolevel/">autolevel</a>
                    <a href="http://alpha6.ru/blog/tag/weight-sensor/">weight sensor</a>
                </p>

        ]]></content>
        <updated>2017-02-09T00:00:00Z</updated>
        <category term="3d-printer" />
        <category term="melzi" />
        <category term="marlin" />
        <category term="rostock" />
        <category term="autolevel" />
        <category term="weight sensor" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/10/18/httpresponse-json/</id>
        <title>Корректное получение JSON ответа с помощью Apache.HttpClient</title>
        <link href="http://alpha6.ru/blog/2016/10/18/httpresponse-json/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>У Apache HttpClient есть небольшая, но неприятная бага. Всплыла она при работе с REST API Confluence (вообще очень много баг всплывает при работе с API  продуктов Atlassian, но это все лирика).</p>

<p>В чем, собственно, проблема? Проблема в том, что Confluence при запросе у него данных с Accept: application/json (собственно все JSON REST API) не выставляет заголовок content-encoding для отдаваемых данных. В целом, его можно понять т.к. по стандарту JSON всегда должен быть UTF-8, но HttpClient не понимает и потому разбирает входящие данные как ISO.</p>

<p>Соответственно, дальше JSONObject при парсинге Entity превращает русский текст в совершенно непотребное.</p>

<p>Лечится это элементарно, просто при работае с Entity принудительно указываем ей что кодировка у нас UTF-8.</p>

<p>Вот так:</p>

<pre><code>JSONObject jsonObj = new JSONObject(EntityUtils.toString(response.getEntity, &quot;UTF-8&quot;));
</code></pre>

<p>После этого русский текст внутри JSON будет в нормальном UTF-8 и с ним можно спокойно работать.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/java/">java</a>
                    <a href="http://alpha6.ru/blog/tag/json/">json</a>
                    <a href="http://alpha6.ru/blog/tag/apache-http/">apache.http</a>
                    <a href="http://alpha6.ru/blog/tag/confluence/">confluence</a>
                </p>

        ]]></content>
        <updated>2016-10-18T00:00:00Z</updated>
        <category term="java" />
        <category term="json" />
        <category term="apache.http" />
        <category term="confluence" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/10/09/orange-pi-armbian-kodi/</id>
        <title>How to fix sound issue with KODI on the orange pi</title>
        <link href="http://alpha6.ru/blog/2016/10/09/orange-pi-armbian-kodi/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>I have Orange Pi One board. It&#39;s a great product, it is faster, cheaper and smaller then Raspberry Pi, but it uses AllWinner H3 SOC and it is its main disadvantage.</p>

<p>If you want to use this board as a media center with KODI, you face the problem with sound. The sound works in Armbian applications but doesn&#39;t work in KODI. It happens because KODI uses S24_LE sampling format which is not supported by Orange Pi hardware.</p>

<pre><code>root@orangepione:~# speaker-test  -D hw:1 -c2 --format S24_LE

speaker-test 1.0.28

Format S24_LE is not supported...
</code></pre>

<p>Ok, we found out the root of the problem, time to fix it!</p>

<p>Now we need to set sampling format which is supported by Orange Pi hardware. One of supported sample formats is S32_LE.
Check if it is correct:</p>

<pre><code>root@orangepione:~# speaker-test  -D hw:1 -c2 --format S32_LE

speaker-test 1.0.28

Playback device is hw:1
Stream parameters are 48000Hz, S32_LE, 2 channels
Using 16 octaves of pink noise
Rate set to 48000Hz (requested 48000Hz)
Buffer size range from 64 to 131072
Period size range from 32 to 16384
Using max buffer size 131072
Periods = 4
</code></pre>

<p>Now check soundcards, we need to get the device number which plays over HDMI output.</p>

<pre><code>root@orangepione:~# cat /proc/asound/cards
 0 [audiocodec     ]: audiocodec - audiocodec
                      audiocodec
 1 [sndhdmi        ]: sndhdmi - sndhdmi
                      sndhdmi
</code></pre>

<p>The <code>sndhdmi</code> is a soundcard which attracts our interest. Remember the number of this one.</p>

<p>Now we can edit the Alsa config:</p>

<pre><code>vim /etc/asound.conf
</code></pre>

<p>Delete old content and paste the following one:</p>

<pre><code>pcm.snd_card {
        type hw
        card 1
        device 0
}

ctl.snd_card {
        type hw
        card 1
        device 0
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave.pcm &quot;snd_card&quot;
    slave {
        period_time 0
        period_size 1024
        buffer_size 4096
        rate 48000
        format S32_LE
        channels 2
    }
    bindings {
        0 0
        1 1
    }
}
</code></pre>

<p>Save the file and reboot.</p>

<p>After that the KODI will play sound.
If it doesn&#39;t play, check the number in <code>card</code> fields of the config, it must be the number from <code>sndhdmi</code> card, and samplerate and samplerate format in <code>slave</code> section. The samplerate should be equal with one from the <code>speaker-test</code> command output.</p>


                <p>Tags:
                    <a href="http://alpha6.ru/blog/tag/orange-pi/">orange pi</a>
                    <a href="http://alpha6.ru/blog/tag/kodi/">kodi</a>
                    <a href="http://alpha6.ru/blog/tag/armbian/">armbian</a>
                </p>

        ]]></content>
        <updated>2016-10-09T00:00:00Z</updated>
        <category term="orange pi" />
        <category term="kodi" />
        <category term="armbian" />
    </entry>
</feed>

