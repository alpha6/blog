<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alpha6.ru/blog/</id>
    <title>Just another blog</title>
    <updated>2016-10-10T00:25:27Z</updated>
    <link href="http://alpha6.ru/blog/index.atom" rel="self" />
    <link href="http://alpha6.ru/blog/" rel="alternate" />
    <generator version="0.077">Statocles</generator>
    <entry>
        <id>http://alpha6.ru/blog/2016/10/09/orange-pi-armbian-kodi/</id>
        <title>How to fix sound issue with KODI on the orange pi</title>
        <link href="http://alpha6.ru/blog/2016/10/09/orange-pi-armbian-kodi/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>I have Orange Pi One board. It&#39;s a great product, it is faster, cheaper and smaller then Raspberry Pi, but it uses AllWinner H3 SOC and it is its main disadvantage.</p>

<p>If you want to use this board as a media center with KODI, you face the problem with sound. The sound works in Armbian applications but doesn&#39;t work in KODI. It happens because KODI uses S24_LE sampling format which is not supported by Orange Pi hardware.</p>

<p>root@orangepione:~# speaker-test  -D hw:1 -c2 --format S24_LE</p>

<p>speaker-test 1.0.28</p>

<p>Format S24_LE is not supported...</p>

<p>Ok, we found out the root of the problem, time to fix it!</p>

<p>Now we need to set sampling format which is supported by Orange Pi hardware. One of supported sample formats is S32_LE.
Check if it is correct:</p>

<p>root@orangepione:~# speaker-test  -D hw:1 -c2 --format S32_LE</p>

<p>speaker-test 1.0.28</p>

<p>Playback device is hw:1
  Stream parameters are 48000Hz, S32_LE, 2 channels
  Using 16 octaves of pink noise
  Rate set to 48000Hz (requested 48000Hz)
  Buffer size range from 64 to 131072
  Period size range from 32 to 16384
  Using max buffer size 131072
  Periods = 4</p>

<p>Now check soundcards, we need to get the device number which plays over HDMI output.</p>

<p>root@orangepione:~# cat /proc/asound/cards
   0 [audiocodec     ]: audiocodec - audiocodec
                        audiocodec
   1 [sndhdmi        ]: sndhdmi - sndhdmi
                        sndhdmi</p>

<p>The <code>sndhdmi</code> is a soundcard which attracts our interest. Remember the number of this one.</p>

<p>Now we can edit the Alsa config:</p>

<p>vim /etc/asound.conf</p>

<p>Delete old content and paste the following one:</p>

<p>pcm.snd_card {
          type hw
          card 1
          device 0
  }</p>

<p>ctl.snd_card {
          type hw
          card 1
          device 0
  }</p>

<p>pcm.dmixer {
      type dmix
      ipc_key 1024
      ipc_perm 0666
      slave.pcm &quot;snd_card&quot;
      slave {
          period_time 0
          period_size 1024
          buffer_size 4096
          rate 48000
          format S32_LE
          channels 2
      }
      bindings {
          0 0
          1 1
      }
  }</p>

<p>Save the file and reboot.</p>

<p>After that the KODI will play sound.
If it doesn&#39;t play, check the number in <code>card</code> fields of the config, it must be the number from <code>sndhdmi</code> card, and samplerate and samplerate format in <code>slave</code> section. The samplerate should be equal with one from the <code>speaker-test</code> command output.</p>

                <p><a href="http://alpha6.ru/blog/2016/10/09/orange-pi-armbian-kodi/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://alpha6.ru/blog/tag/orange-pi/">orange pi</a>
                <a href="http://alpha6.ru/blog/tag/kodi/">kodi</a>
                <a href="http://alpha6.ru/blog/tag/armbian/">armbian</a>
            </p>
        ]]></content>
        <updated>2016-10-09T00:00:00Z</updated>
        <category term="orange pi" />
        <category term="kodi" />
        <category term="armbian" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/10/08/orange-pi-power-connector/</id>
        <title>Orange Pi power connector</title>
        <link href="http://alpha6.ru/blog/2016/10/08/orange-pi-power-connector/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Orange Pi can&#39;t work with USB power. It needs power from power connector or GPIO.</p>

<p>If you need a fast and dirty way, use the GPIO pins. You may use standard smartphone charger with USB connector and 1A current.
If you want to use external HDD with Orange Pi, you need power supply with 2+ A current.
After you have found a charger, just connect +5V from USB to GPIO pin 2 (or pin 4, they are similar) and USB ground with pin 6.</p>

<p><img alt="GPIO pinout diagram" src="http://cs5-3.4pda.to/8498940.png"></p>

<p>The first pin is marked with white triangle near the GPIO connector.</p>

<p>The right way is to use the power plug. But Orange Pi uses power connector which is not common.
You need the connector with 4.0x1.7 mm diameter and 8mm long (or longer). In the shop where I bought the connector it was being sold as connector for Compaq notebooks.
You need to solder +5V from the USB to the central contact of the connector and USB ground to the external contact.</p>

                <p><a href="http://alpha6.ru/blog/2016/10/08/orange-pi-power-connector/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://alpha6.ru/blog/tag/orangepi/">orangepi</a>
                <a href="http://alpha6.ru/blog/tag/diy/">diy</a>
                <a href="http://alpha6.ru/blog/tag/power/">power</a>
            </p>
        ]]></content>
        <updated>2016-10-08T00:00:00Z</updated>
        <category term="orangepi" />
        <category term="diy" />
        <category term="power" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/09/08/send-html-email-with-perl/</id>
        <title>Отправляем емейл из Perl с авторизацией и html</title>
        <link href="http://alpha6.ru/blog/2016/09/08/send-html-email-with-perl/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Отправляем письмо в html с авторизацией из Perl.</p>

<pre><code>use strict;
use Net::SMTP;
use Authen::SASL; #нужен для авторизации

use utf8;
use Encode;
use MIME::Base64


  my $message = &quot;&lt;html&gt;&lt;body&gt;Тестовое письмо&lt;/body&gt;&lt;/html&gt;&quot;;

# авторизационные данные
my $smtp_host = &#39;smtp.server.address&#39;;
my $smtp_user = &#39;user_name&#39;;
my $smtp_pass = &#39;password&#39;;


my $debug = 1; # рассматриваем процесс подключения в деталях

# mail properties
my $mail_from = &#39;user@example.com&#39;;
my $mail_to = &#39;recipient@example.com&#39;;
my $mail_subject = &#39;Тестовое письмо&#39;;

# Выставляем заголовки. Сюда можно добавить еще всякого при необходимости
my $mail_headers = &quot;From: $mail_from\n&quot;.
&quot;To: $mail_to\n&quot;.
&quot;Subject: &quot;.encode(&#39;MIME-Header&#39;,$mail_subject).&quot;\n&quot;.
&quot;MIME-Version: 1.0\n&quot;.
&quot;Content-type: text/html; charset=UTF-8\n&quot;.
&quot;Content-Transfer-Encoding: base64\n\n&quot;;

my $mail_body = $message;

# Отправляем письмо
my $smtp = Net::SMTP-&gt;new($smtp_host, Debug =&gt; $debug) or die &quot;cannot connect to server&quot;;
$smtp-&gt;auth($smtp_user,$smtp_pass) or die &quot;could not authenticate&quot;;
$smtp-&gt;mail($mail_from);
$smtp-&gt;to($mail_to);
$smtp-&gt;data();
$smtp-&gt;datasend($mail_headers);
$smtp-&gt;datasend(encode_base64(encode(&#39;UTF-8&#39;, $mail_body)));
$smtp-&gt;dataend();
$smtp-&gt;quit;
</code></pre>

<p>При необходимости можно добавить файлы, PGP подписи и так далее.</p>

                <p><a href="http://alpha6.ru/blog/2016/09/08/send-html-email-with-perl/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://alpha6.ru/blog/tag/perl/">perl</a>
                <a href="http://alpha6.ru/blog/tag/net-smtp/">Net::SMTP</a>
                <a href="http://alpha6.ru/blog/tag/email/">email</a>
            </p>
        ]]></content>
        <updated>2016-09-08T00:00:00Z</updated>
        <category term="perl" />
        <category term="Net::SMTP" />
        <category term="email" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/09/04/marlin-adding-second-extruder/</id>
        <title>Добавляем второй экструдер к RAMPS 1.4/Marlin</title>
        <link href="http://alpha6.ru/blog/2016/09/04/marlin-adding-second-extruder/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>В <a href="http://alpha6.ru/blog/2016/08/23/marlin-setup/">прошлой серии</a> мы установили прошивку Marin на Arduino Mega+RAMPS 1.4 и откалибровали все это дело. Теперь пришло время добавить второй экструдер.</p>

<p>Для этого нам понадобится:</p>

<ul>
<li>второй экструдер</li>
<li>второй хот-энд в сборе и все прилегающие детали, типа трубки боудена</li>
<li>каретка на два экструдера. Я использую <a href="http://www.thingiverse.com/thing:1749633">такую</a>.</li>
</ul>

<p>В общем случае все просто идем в Arduino IDE и правим конфигурацию.</p>

<p>Меняем конфигурацию платы управления на RAMPS 1.4 c 2 экструдерами и подогреваемым столом</p>

<pre><code>#ifndef MOTHERBOARD
  #define MOTHERBOARD BOARD_RAMPS_14_EEB
#endif
</code></pre>

<p>Указываем кол-во экструдеров:</p>

<pre><code>#define EXTRUDERS 2
</code></pre>

<p>Указываем тип датчика температуры для второго экструдера:</p>

<pre><code>#define TEMP_SENSOR_1 1
</code></pre>

<p>Максимальную температуру:</p>

<pre><code>#define HEATER_1_MAXTEMP 250
</code></pre>

<p>Если надо, устанавливаем направление вращения мотора:</p>

<pre><code>#define INVERT_E1_DIR true
</code></pre>

<p>В целом, если у вас одинаковые моторы на обоих экструдерах, то на этом настройка закончена.</p>

<p>Но если у моторы разные или  на одном экструдере у меня мотор с шестерней подачи диаметром 10мм, а на втором - 7мм, то тут начинаются проблемы с калибровкой.</p>

<p>Как откалибровать второй экструдер?
Идем в пронтерфейс и говорим:</p>

<pre><code>T1
</code></pre>

<p>Эта команда указывает что сейчас активен экструдер номер 2 (отсчет начинается с 0). Включаем подачу филамента, для подачи будет использоваться число шагов из прошивки, т.е. для первого экструдера. Смотрим разницу и с помощью пропорции получаем кол-во шагов для активного экструдера. У меня из-за разницы в подающих шестернях получилось 80 шагов на мм.</p>

<p>Говорим:</p>

<pre><code>M92 E80
</code></pre>

<p>Этим мы устанавливаем новое кол-во шагов для текущего экструдера. Проверяем, при необходимости подгоняем значение.</p>

<p>После калибровки вылезает проблема - Marlin не поддерживает установку разного числа шагов для разных экструдеров, соответственно в прошивке нам эти данные не сохранить. Придется этот вопрос решать програмно.</p>

<p>Напишем небольшой фильтр которым будем обрабатывать готовый g-code файл.</p>

<pre><code>#!/usr/bin/env perl

use strict;

my $T0 = &#39;M92 E95&#39;;
my $T1 = &#39;M92 E80&#39;;

local $^I = &#39;.bak&#39;;
while (&lt;&gt;) {
    s/^T0/T0\n$T0/;
    s/^T1/T1\n$T1/;
    print;
}
</code></pre>

<p>Этот скрипт ищет команду T<num> и заменяет ее нужным нам значением. В данном случае добавляет команду M92 E<steps>.
Скрипт получает на вход имя файла, перебирает его построчно и в каждой строке заменяет совпадения на то что мы указали. Оригинальный файл сохраняется с расширением <code>.bak</code>.</steps></num></p>

<p>Дальше нам надо задать смещение экструдеров</p>

<p>Для Slic3r идем в <code>Printer Settings</code> -&gt; <code>Extruder 2</code> и выставляем смещение. Примерное смещение можно получить если измерив расстояние между соплами, однако программое расстояние может отличаться от физического расстояния, так что все равно придется заняться калибровкой.</p>

<p>Для этого печатаем деталь для <a href="http://www.thingiverse.com/thing:124450">калибровки 2х экструдеров</a> и точно подгоняем все для идеальной работы.</p>

                <p><a href="http://alpha6.ru/blog/2016/09/04/marlin-adding-second-extruder/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://alpha6.ru/blog/tag/prusai3/">prusai3</a>
                <a href="http://alpha6.ru/blog/tag/marlin/">marlin</a>
                <a href="http://alpha6.ru/blog/tag/slic3r/">Slic3r</a>
            </p>
        ]]></content>
        <updated>2016-09-04T00:00:00Z</updated>
        <category term="prusai3" />
        <category term="marlin" />
        <category term="Slic3r" />
    </entry>
    <entry>
        <id>http://alpha6.ru/blog/2016/08/23/marlin-setup/</id>
        <title>Настраиваем прошивку Marlin для Arduino + RAMPS 1.4</title>
        <link href="http://alpha6.ru/blog/2016/08/23/marlin-setup/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Так получилось что некоторое время назад я стал владельцем китайского клона Prusa i3 под гордым китайским названием Hesine M505.
Это чудо китайской мысли конечно было далеко от совершенства, но с задачей печатать все подряд справлялось вполне успешно. Однако, чем дальше в лес - тем толще партизаны. И забравшись в лес подальше возжелал я печатать детали с использованием растворимых поддержек, да и двумя цветами печатать тоже было бы  неплохо.</p>

<p>К сожалению, у родной для принтера платы Melzi V2 был фатальный недостаток - на ней отсутсвовал порт для подключения второго экструдера. Изучение матчасти показало, что можно взять еще одну такую же плату и воткнуть ее в режиме слейва. Однако ценник на это удовольствие получался высоковатым. И, что самое неприятно, при таком апгрейде терялась возможность подключения экрана и кнопок управления. Т.е. печатать можно будет только с компьютера, а это не самая лучшая идея по многим причинам.</p>

<p>Так я пришел к решению полностью заменить мозги принтера. Выбор был сделан в пользу нестареющей класски Arduino Mega 2560 + RAMPS 1.4 + A4988. Быстро сказка сказывается, да долго посылочка едет. Получив посылку с мозгами, моторами и прочим полезным в хозяйстве инвентарем я обнаружил что забыл заказать шестерню податчика экструдера. Благо на тот момент она уже ехала ко мне с али, где я заказал ее просто так, от жадности.</p>

<p>В общем, пока необходимые запчасти едут, можно подключить и отстроить новые мозги в конфигурации с одним экструдером, а потом просто переконфигурировать прошивку когда будет собрано все железо.</p>

<p>Ставить мы будем классику жанра - Marlin. Клонируем репозиторий в любое удобное место отсюда https://github.com/MarlinFirmware/Marlin. Скачиваем Arduino IDE.</p>

<p>В Arduino IDE открываем прошивку.
Выбираем нашу плату Arduino Mega 2560 и процессор AtMega 2560.</p>

<p>Дальше нас интересует вкладка с файлом Configuration.h, теперь мы будем его безудержно править.</p>

<p>Выбираем нашу плату: RAMPS 1.4 с одним хотэндом</p>

<pre><code>#ifndef MOTHERBOARD
  #define MOTHERBOARD BOARD_RAMPS_14_EFB
#endif
</code></pre>

<p>В файле boards.h приведен полный список поддерживаемых плат и их вариаций. Нас пока интересует только RAMPS 1.4 с одним экструдером.</p>

<p>Выставляем кол-во температурных сенсоров. Сенсоров должно быть по числу экструдеров. В нашем случае 1. Убеждаемся что напротив первого сенсора в списке стоит 1.</p>

<pre><code>#define TEMP_SENSOR_0 1
</code></pre>

<p>Выставляем максимальную температуру хотэнда и стола.</p>

<pre><code>#define HEATER_0_MAXTEMP 250
#define BED_MAXTEMP 130
</code></pre>

<p>У меня стоят термопредохранители на 252 градуса, так что максимальная температура хота должна быть ниже температуры срабатывания предохранителя. Если собираетесь печатать чем-то вроде поликарбоната - то температуру надо поднять. Со столом таже история, единственное что даже печать нейлоном не требует очень больших температур стола, 130 градусов должно хватить всем.</p>

<p>В Hesine M505 стоят нормально замкнутые концевики, а в прошивка по умолчанию рассчитывает на нормально разомкнутые.
Включаем инвертирование концевиков:</p>

<pre><code>// Mechanical endstop with COM to ground and NC to Signal uses &quot;false&quot; here (most common setup).
#define X_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
#define Y_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
#define Z_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
</code></pre>

<p>Проверяем направление вращения моторов. Тут история примерно таже что и с концевиками, т.к. прошивка изначально рассчитана на Ultimaker.</p>

<pre><code>// Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
#define INVERT_X_DIR true
#define INVERT_Y_DIR true
#define INVERT_Z_DIR false
</code></pre>

<p>И для экструдера повторяем операцию.</p>

<pre><code>#define INVERT_E0_DIR true
</code></pre>

<p>Выставляем размеры рабочей зоны</p>

<pre><code>#define X_MIN_POS 0
#define Y_MIN_POS 0
#define Z_MIN_POS 0
#define X_MAX_POS 250
#define Y_MAX_POS 230
#define Z_MAX_POS 140
</code></pre>

<p>Для начала можно выставить заводомо большие чем рабочая зона габариты. Потом все откалибруется по месту. По умолчанию в прошивке стоят значени 200х200х200, тогда как у Hesine M505 рабочее поле по всем направлениям больше чем эти цифры. И прошивка просто не даст двигаться за их пределы.</p>

<p>Устанавливаем координаты начала стола. Это нужно чтобы ноль стола в слайсере совпадал с нулем в координатах принтера. Иначе модель может вылезать за пределы зоны печати.</p>

<pre><code>#define MANUAL_X_HOME_POS -30
#define MANUAL_Y_HOME_POS -20
</code></pre>

<p>Выставляем шаги для моторов.</p>

<pre><code>#define DEFAULT_AXIS_STEPS_PER_UNIT   {100,100,1600,95}
</code></pre>

<p>Параметры тут следующие: мотор_Х, мотор_Y, мотор_Z, мотор_экструдера</p>

<p>Для рассчета шагов по X и Y используем следующую формулу:</p>

<pre><code>(200*16)/(16*2)=80 шагов
</code></pre>

<p>Где 200 - это число шагов двигателя на 360 градусов. Типичная цифра для моторов с шагом 1.8 градуса.
16 в числителе - кол-во микрошагов на шаг.
16 в знаменателе - кол-во зубов на шпуле.
2 - стандартный шаг для ремня GT2</p>

<p>Для Z:</p>

<pre><code>3200/2 = 1600
</code></pre>

<p>В Hesine M505 штатно используется трапециидальный винт с шагом резьбы 2мм. Соответственно мы белим число шагов на полный оборот на кол-во миллиметров которые будут пройдены за оборот и получаем число шагов на миллиметр.</p>

<p>Подачу экструдера пока посчитаем и выставим предварительно. Потом ее все равно придется подгонять.
Шестерня экструдера штатно имеет диаметр около 10мм. Получаем длинну окружности на один оборот: 3.14*10=31.4 мм на оборот.</p>

<p>Делим число шагов на длинну окружности и получаем число шагов на миллиметр.</p>

<pre><code>3200/31.4=101.9
</code></pre>

<p>округляем до 102.</p>

<p>Заливаем все это дело в Arduino.</p>

<p>После того как все залилось и все железо подключено запускаем Pronterface и начинаем калибровку.</p>

<ul>
<li>Двигаем моторы и проверяем что они крутятся в нужную сторону. Если это не так - меняем параметр INVERT_*_DIR на противоположное значение.</li>
<li>Проверяем состояние концевиков. По команде M119 будет показано состояние концевиков. Если концевик нажат - напротив него должно быть написано TRIGGERED. Напротив ненажатого - open. Если это не так - меняем настройку *<em>MIN</em>ENDSTOP_INVERTING.</li>
<li>Даем команду G28. Все оси должны приехать в свое минимальное положение. Дальше через Pronterface двигаем все оси в их безопасное максимальное положение и даем комаду M114. Она покажет текущее положение по осям. Вносим эти данные в настройку *<em>MAX</em>POS.</li>
<li>Опять говорим G28. Передвигаем экструдер в нулевую координату стола по X-Y. Смотрим что показывает M114 и эти цифры переносим в MANUAL_*<em>HOME</em>POS с обратным знаком. Т.е. если M114 говорит что координата по Х сейчас 30 - то в настройку пишем -30. Это значит что после ухода в HOME экструдер отъедет от него на 30мм и будет считать это положение нолем.</li>
<li>откручиваем сопло или трубку боудена у экструдера. На прутке отмечаем расстояние, например 10 см, и прогоняем эту же длинну из Pronterface. После этого смотрим сколько в реальности прошло прутка и корректируем кол-во шагов для экструдера чтобы он прогонял четко нужное кол-во пластика. Важно понимать что на горячую с установленным соплом эта цифра все равно будет отличаться от установленного. Если вы всегда печатаете соплом одного диаметра - можно повторить эту операцию с соплом и полученные данные внести в прошивку. Я использую несколько сопел, так что объем пластика корректирую через настройку потока в слайсере.</li>
</ul>

<p>После того как все это сделано - печатаем тестовую модель. Я использую пустой куб 20х20х20 мм. После того как он отпечатан - проверяем что размеры сторон у нас точно соответсвуют тому что должно быть. Если это не так по отдельным измерениям - корректируем кол-во шагов для нужной оси.</p>

<p>На этом основные настройки закончены. Дальше можно тюнить приведенные выше параметры для более качественной печати.</p>

                <p><a href="http://alpha6.ru/blog/2016/08/23/marlin-setup/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://alpha6.ru/blog/tag/prusai3/">prusai3</a>
                <a href="http://alpha6.ru/blog/tag/3dprinting/">3dprinting</a>
                <a href="http://alpha6.ru/blog/tag/ramps/">ramps</a>
                <a href="http://alpha6.ru/blog/tag/marlin/">marlin</a>
            </p>
        ]]></content>
        <updated>2016-08-23T00:00:00Z</updated>
        <category term="prusai3" />
        <category term="3dprinting" />
        <category term="ramps" />
        <category term="marlin" />
    </entry>
</feed>

